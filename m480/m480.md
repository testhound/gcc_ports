/* Definitions of target machine for Mindspeed MXT400 Network Processor

   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
   Contributed by Michael Collison and K. Kiran Kumar

   This file is part of GNU CC.

   GNU CC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   GNU CC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GNU CC; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA. */


(define_attr "cpu" "m480"
  (const
   (cond [(symbol_ref "TARGET_480") (const_string "m480")]
	 (const_string "m480"))))

(define_attr "length" ""
  (const_int 1))

(define_attr "type" "arith,logical,bitfield,brspre,brsl,bnzr,bnzi,bzr,bzi,cmp_br,
                     cmpi_br,compare,depb,depbi,dma,extb,get,put,nop,link,mvrh,mvhr,
                     tclrb,tsetb,lih,lil,lwih,lwil,lil_or_lih,lail,laih,lail_or_laih,
                     lmms,lmm_single,lsp,lmm,lmm2,lmm3,lmm4,lmm5,lmm6,lmm7,lmm8,lmm9,
                     smm7,lmm10,lmm11,ssp,smm_single,smm,smms,smm2,smm3,smm4,smm5,
                     smm6,smm8,smm9,smm10,smm11,branch,alu2opbranch,branch_indirect,cbranch,call,
                     mul,muli,mulh,mulhi,multi,cond_move,move_hardware,idiv,imul,
                     move_value,unlink,hec5_branch,unknown"
  (const_string "unknown"))

(define_attr "instruction" "add,add4x,addc,addci,addi,addl,addli,addne,addnei,addwh,addwhi,
                            addwl,addwli,addww,addwwi,and,andi,bci,bcr,bi,bnzi,bnzr,br,brs,
                            brsl,brspre,bzr,bzi,bytesw,clrb,clrbi,cmov,cmovi,cmp,cmpi,cmpr,
                            cmpri,depb,depbi,dmap,dmasr,dmau0,dmau1,extb,ffs,fls,get,hec5,
                            lail,laih,lil,lih,link,lmm,lwih,lwil,max,maxi,min,mini,mul,muli,
                            mulh, mulhi,mvhr,mvrh,or,ori,par,putc,putm,putp,rand,randi,rnmi,
                            rint,rotl,rotli,rotr,rotri,setb,setbi,shft,shfta,shl,shli,shr,
                            shra,shrai,shri,smm,sub,subb,subbi,subi,subl,subli,subwh,subwhi,
                            subwl,subwli,subww,subwwi,tclrb,tsetb,xor,xori,unlink,unknown"
  (const_string "unknown"))

(define_attr "octave_class" "alu3op,alu3opabcmod,alu3opabc,alu2op,alu2opbranch,alu2opfind,
                             alu3opsx,aluop,condbranch,zerobranchimmed,testbitbranch,
                             returnop,zerobranch,condbranchimmed,bitop,bitopimmed,
                             compareop,compareopsign,singleload,singlestore,jumpop,
                             multiload,multistore,multilink,multiregop,loadop,brtosrvc,
                             cmovop,dmaop,mvop,mvhop,branchop,tssrcop,octave"
  (const_string "octave"))

(define_attr "bme_dest_reg" "swepd,bmecfg,none"
    (const_string "none"))

(define_attr "mvrh_dest_reg" "r64,r65,r66,r67,r68,r69,
                              r70,r71,r72,r73,r74,r75,r76,r77,r78,r79,
                              r80,r81,r82,r83,r84,r85,r86,r87,r88,r89,
                              r90,r91,r92,r93,r94,r95,r96,r97,r98,r99,
                              r100,r101,r102,r103,r104,r105,r106,r107,r108,r109,
                              r110,r111,r112,r113,r114,r115,r116,r117,r118,r119,
                              r120,r121,r122,r123,r124,r125,r126,r127,none"
  (const_string "none"))

(define_asm_attributes
  [(set_attr "type" "multi")])

(define_attr "memory_region" "spram,spram_lock,sram,sdram,ccram,ccram_lock,sio,none"
  (const_string "none"))
 
(define_attr "mem_transfer_size" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16"
  (const_string "0"))

(define_attr "reg_linked_to_mem" "false,true"
  (const_string "false"))

(define_attr "linked_mem_update" "false,true"
  (const_string "false"))

(define_attr "odd_register_multiload" "false,true"
  (const_string "false"))

(define_attr "odd_register_multistore" "false,true"
  (const_string "false"))

(define_attr "zerobranch_is_call" "false,true"
  (const_string "false"))


(define_attr "in_unconditional_delay_slot" "false,true"
  (if_then_else (eq_attr "type" "!branch,cbranch,bnzr,bnzi,bzr,bzi,tclrb,
                                      tsetb,cmp_br,cmpi_br,call,compare,multi,
                                      move_hardware,brsl,unknown")
		(const_string "true")
		(const_string "false")))

(define_attr "in_conditional_delay_slot" "false,true"
  (if_then_else (eq_attr "type" "!branch,cbranch,bnzr,bnzi,bzr,bzi,tclrb,
                                 tsetb,cmp_br,cmpi_br,call,compare,multi,
                                 move_hardware,brsl,unknown")
			  (const_string "true")
			  (const_string "false")))

(define_attr "in_annul_slot_1" "false,true"
  (if_then_else (eq_attr "type" "!branch,cbranch,bnzr,bnzi,bzr,bzi,tclrb,
                                  tsetb,cmp_br,cmpi_br,brsl,call,compare,multi,
                                  unknown")
		(const_string "true")
		(const_string "false")))

(define_attr "in_annul_slot_2" "false,true"
  (if_then_else (eq_attr "type" "!branch,cbranch,bnzr,bnzi,bzr,bzi,tclrb,
                                  tsetb,cmp_br,cmpi_br,call,compare,brsl,multi,
                                  unknown")
		(const_string "true")
		(const_string "false")))

;; Branch delay slot
;; Unconditional branches have 1 delay slot and no annul slots

(define_delay (eq_attr "type" "branch")
  [(eq_attr "in_unconditional_delay_slot" "true")
   (nil) 
   (nil)])

(define_delay (eq_attr "type" "hec5_branch,alu2opbranch")
  [(eq_attr "in_conditional_delay_slot" "true")
   (nil) 
   (nil)])

;; Brsl has one delay slot
;; Unfortunately we can only place instructions that don't use any context 
;; registers in the delay slots, further no dma iinstruction may be put in 
;; the committed slot
;; For now until we flesh out the machine description to handle these 
;; nuances, only allow nops in delay slots.
(define_delay (eq_attr "type" "brsl")
  [(eq_attr "type" "get,put,nop")
   (nil) (nil)])

;; Calls have 1 delay slot and no annul slots
(define_delay (eq_attr "type" "call")
  [(eq_attr "in_unconditional_delay_slot" "true")
   (nil) (nil)])

;; Conditional branches have 2 delay/annul slots
(define_delay (eq_attr "type" "cbranch")
  [(eq_attr "in_conditional_delay_slot" "true")
   (eq_attr "in_annul_slot_1" "true")
   (eq_attr "in_annul_slot_1" "true")

   (eq_attr "in_conditional_delay_slot" "true")
   (eq_attr "in_annul_slot_2" "true")
   (eq_attr "in_annul_slot_2" "true")])

;; tclrb and tsetb have 3 delay slots
(define_delay (eq_attr "type" "tclrb,tsetb,cmp_br,cmpi_br")
  [(eq_attr "in_conditional_delay_slot" "true") (nil) (nil)
   (eq_attr "in_conditional_delay_slot" "true") (nil) (nil)
   (eq_attr "in_conditional_delay_slot" "true") (nil) (nil)])

;; bnzr and bnzi have 2 delay slots
(define_delay (eq_attr "type" "bnzr,bnzi,bzr,bzi")
  [(eq_attr "in_conditional_delay_slot" "true") (nil) (nil)
   (eq_attr "in_conditional_delay_slot" "true") (nil) (nil)])

(include "m480_dfa.md")

(define_constants
  [(REG_0 0)
   (REG_1 1)
   (REG_2 2)
   (REG_3 3)
   (REG_4 4)
   (REG_5 5)
   (REG_6 6)
   (REG_7 7)
   (REG_8 8)
   (REG_9 9)
   (REG_10 10)
   (REG_11 11)
   (REG_12 12)
   (REG_13 13)
   (REG_14 14)
   (REG_15 15)
   (REG_16 16)
   (REG_17 17)
   (REG_18 18)
   (REG_19 19)
   (REG_20 20)
   (REG_21 21)
   (REG_22 22)
   (REG_23 23)
   (REG_24 24)
   (REG_25 25)
   (REG_26 26)
   (REG_27 27)
   (REG_28 28)
   (REG_29 29)
   (REG_30 30)
   (REG_31 31)
   (REG_32 32)
   (REG_33 33)
   (REG_34 34)
   (REG_35 35)
   (REG_36 36)
   (REG_37 37)
   (REG_38 38)
   (REG_39 39)
   (REG_40 40)
   (REG_41 41)
   (REG_42 42)
   (REG_43 43)
   (REG_44 44)
   (REG_45 45)
   (REG_46 46)
   (REG_47 47)
   (REG_48 48)
   (REG_49 49)
   (REG_50 50)
   (REG_51 51)
   (REG_52 52)
   (REG_53 53)
   (REG_54 54)
   (REG_55 55)
   (REG_56 56)
   (REG_57 57)
   (REG_58 58)
   (REG_59 59)
   (REG_60 60)
   (REG_61 61)
   (REG_62 62)
   (REG_63 63)
   (REG_64 64)
   (REG_65 65)
   (REG_ESS 66)
   (REG_67 67)
   (REG_68 68)
   (REG_69 69)
   (REG_70 70)
   (REG_71 71)
   (REG_72 72)
   (REG_73 73)
   (REG_74 74)
   (REG_75 75)
   (REG_76 76)
   (REG_77 77)
   (REG_78 78)
   (REG_79 79)
   (REG_80 80)
   (REG_81 81)
   (REG_82 82)
   (REG_83 83)
   (REG_84 84)
   (REG_85 85)
   (REG_86 86)
   (REG_87 87)
   (REG_88 88)
   (REG_89 89)
   (REG_90 90)
   (REG_91 91)
   (REG_92 92)
   (REG_93 93)
   (REG_94 94)
   (REG_95 95)
   (REG_96 96)
   (REG_97 97)
   (REG_98 98)
   (REG_99 99)
   (REG_100 100)
   (REG_BASE2 101)
   (REG_BASE3 102)
   (REG_103 103)
   (REG_104 104)
   (REG_105 105)
   (REG_106 106)
   (REG_107 107)
   (REG_108 108)
   (REG_109 109)
   (REG_110 110)
   (REG_111 111)
   (REG_112 112)
   (REG_113 113)
   (REG_114 114)
   (REG_115 115)
   (REG_116 116)
   (REG_117 117)
   (REG_118 118)
   (REG_119 119)
   (REG_120 120)
   (REG_121 121)
   (REG_122 122)
   (REG_123 123)
   (REG_124 124)
   (REG_125 125)
   (REG_126 126)
   (REG_127 127)
   (REG_ESS_PIT1         128)
   (REG_ESS_PIT0         129)
   (REG_ESS_BRALWAYS     130)
   (REG_ESS_SRDMARQFULL  131)
   (REG_ESS_PDMARQFULL   132)
   (REG_ESS_UDMA0RQFULL  133)
   (REG_ESS_UDMA1RQFULL  134)
   (REG_ESS_BMESWEPD     135)
   (REG_ESS_BMEHWEPD     136)
   (REG_ESS_BMEEXHAUST   137)
   (REG_ESS_INT          138)
   (REG_ESS_NMI          139)
   (REG_ESS_OVERFLOW     140)
   (REG_ESS_CARRY        141)
   (REG_LNK1             142)
   (REG_LNK2             143)
   (REG_LNK3             144)
   (REG_ARG_PTR          145)
   (REG_RET_ADDR_PTR     146)
   (REG_TEMP_FP          147)
   (REG_FAKE_SP          148)
   (REG_BASE_SDRAM       149)
   (REG_BASE_SRAM        150)
   (REG_BASE_CCRAM       151)
   (REG_BASE_CCRAM_LOCK  152)
   (REG_BASE_SIO         153)
   (REG_BASE_SPRAM       154)
   (REG_BASE_SPRAM_LOCK  155)
   (REG_TSS_GET_PTR      156)
   (REG_TSS_PUT_PTR      157)

])

(define_constants 
  [(FLAG_UNLNK          300)
   (FLAG_DLNK           301)
   (FLAG_FLUSH          302)
   (FLAG_PRE            303)
   (FLAG_SIGN           304)
   (FLAG_Z              305)
   (FLAG_ZB             306)
   (FLAG_CUME           307)
   (FLAG_RB             308)
   (FLAG_FP             309)
   (FLAG_NT             310)
   (FLAG_NB             311)
   (FLAG_NC             312)
   (FLAG_S              313)
   (FLAG_A              314)
   (FLAG_R              315)
   (FLAG_NUL            316)
   (FLAG_GR             317)
   (FLAG_GW             318)
   (FLAG_FR             319)
   (FLAG_GU             320)
   (FLAG_GZ             321)
   (FLAG_NE             322)
   (FLAG_CLOSE          323)
   (FLAG_RSCH           324)
   (FLAG_H              325)
   (FLAG_I              326)
   (FLAG_DI             327)
   (FLAG_CD             328)
   (FLAG_FPB            329)
   (FLAG_CSB            330)
   (FLAG_DELETE         331)
   (FLAG_OAM            332)
   (FLAG_RP             333)
   (FLAG_LOG            334)
   (FLAG_T              335)])


(define_constants 
  [(MEM_SDRAM          400)
   (MEM_SPRAM          401)
   (MEM_SPRAM_LOCK     402)
   (MEM_SRAM           403)
   (MEM_CCRAM          404)
   (MEM_CCRAM_LOCK     405)
   (MEM_SIO            406)])

;
; C compiler related unspec constants
;

(define_constants 
  [(ADD_FOR_UNALIGNED  500)
   (SAVE_ESS           501)
   (RESTORE_ESS        502)
   (ADD_FOR_RELOAD     503)])

;
; UNSPEC constants
;

(define_constants [
		   (U_BRS          0)
		   (U_BRSL         1)
		   (U_BRSPRE       2)
		   (U_BYTESW       3)
		   (U_DMAP         4)
		   (U_DMAU0        5)
		   (U_DMAU1        6)
		   (U_FLS          7)
		   (U_GET          8)
		   (U_HEC5         10)
		   (U_LINK         11)
		   (U_LMMS         12)
		   (U_LSP          13)
		   (U_MVHR         16)
		   (U_MVRH         17)
		   (U_PAR          18)
		   (U_POL          19)
		   (U_PUTC         21)
		   (U_PUTM         22)
		   (U_RAND         23)
		   (U_RANDI        24)
		   (U_RINT         25)
		   (U_RNMI         26)
		   (U_SMMS         27)
		   (U_SSP          29)
		   (U_UNLINK       32)
		   (U_DMASR        33)
		   (U_MV           34)
		   (U_FLS_ZB       35)
		   (U_FFS          36)
		   (U_LINKS        37)
		   (U_CD_FLAG      38)
		   (U_LO16         39)
		   (U_LO17         40)
		   (U_LIH          41)
		   (U_LIL          42)
		   (U_LWIH         43)
		   (U_LWIL         44)
		   (U_LAIH         45)
		   (U_PUTP         46)
		   (U_NOP          47)
		   (U_BME_SWEPD    48)
		   (U_BME_HWEPD    49)
		   (U_BME_CFG      50)
		   (U_SAVE_TRAP_PC 51)
		   (U_ACTIVEID     52)
		   (U_ACTIVEID2    53)
		   (U_ACTIVEID3    54)
		   (U_GETBME_BUF   55)
		   (U_OCTCFG       56)
		   (U_OCTTRAP      57)
		   (U_OCTOAM       58)
		   (U_OCTTRAPEN    59)
		   (U_OCTGLBITAG   60)
		   (U_OCTCTL       61)
		   (U_OCTRTCCTL    62)
		   (U_OCTDIAG      63)
		   (U_OCTLPTR0     64)
		   (U_OCTLPTR16    65)
		   (U_OCTLPTR32    66)
		   (U_OCTLPTR48    67)
		   (U_OCTLBASE1    68)
		   (U_OCTLBASE2    69)
		   (U_OCTLBASE3    70)
		   (U_OCTACTIVECID        71)
		   (U_OCTACTIVECIDXOR     72)
		   (U_OCTOAM_ATMHDR       73)
		   (U_OCTOAM_ATMPAYLOAD   74)
		   (U_GET_WRAPPER         75)])

(define_expand "lo16"
  [(const (unspec [(match_operand 0 "" "")] U_LO16))]
  ""
  "")

(define_expand "hi16"
  [(const (high (match_operand 0 "" "")))]
  ""
  "")

(define_expand "lo17"
  [(const (unspec [(match_operand 0 "" "")] U_LO17))]
  ""
  "")

;
;  ADD/ADDI Add Registers 
;  ADDI: Add Register w/ Immediate
;    
;  add rsa rsb rd [MODX] [ABC]
;  addi rsa usi6 rd [MODX] [ABC]
;

(define_insn "add"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (plus:SI (match_operand:SI 1 "register_operand" "%rZ,rZ,rZ")
		  (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	(plus:SI (match_dup 1)
		 (match_dup 2)))]
  ""
  "@
   add  %r1 %r2 %r0
   addi %r1 %2 %r0
   subi %r1 %n2 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "add,addi,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")])

(define_insn "add_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	(plus:SI (match_operand:SI 1 "register_operand" "%rZ,rZ,rZ")
		  (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P")))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   add  %r1 %r2 %r0
   addi %r1 %2 %r0
   subi %r1 %n2 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "add,addi,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")])

(define_insn "add_lnk"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (plus:SI (match_operand:SI 1 "register_operand" "%rZ,rZ,rZ")
		  (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	(plus:SI (match_dup 1)
		 (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S,S")
	(plus:SI (match_dup 1)
		 (match_dup 2)))]
  ""
  "@
   add  %r1 %r2 %r0
   addi %r1 %2 %r0
   subi %r1 %n2 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "add,addi,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true,true")])

(define_insn "add_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	(plus:SI (match_operand:SI 1 "register_operand" "%rZ,rZ,rZ")
		 (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P")))
   (set (match_operand:SI 3 "memory_operand" "=S,S,S")
	(plus:SI (match_dup 1)
		 (match_dup 2)))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   add  %r1 %r2 %r0
   addi %r1 %2 %r0
   subi %r1 %n2 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "add,addi,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true,true")])

(define_insn "add_modx"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (plus:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P")
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (plus:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2) (match_dup 3)))))]
  ""
  "@
  add  %r1 %r2 %r0 %X3
  addi %r1 %2 %r0 %X3
  subi %r1 %n2 %r0 %X3"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "add,addi,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")])

(define_insn "add_modx_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	(ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (plus:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P")
		   (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
  add  %r1 %r2 %r0 %X3
  addi %r1 %2 %r0 %X3
  subi %r1 %n2 %r0 %X3"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "add,addi,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")])

(define_insn "add_modx_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (plus:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P")
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (plus:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S,S,S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (plus:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))]
  ""
  "@
  add  %r1 %r2 %r0 %X3
  addi %r1 %2 %r0 %X3
  subi %r1 %n2 %r0 %X3"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "add,addi,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true,true")])

(define_insn "add_modx_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (plus:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P")
		   (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S,S,S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (plus:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
  add  %r1 %r2 %r0 %X3
  addi %r1 %2 %r0 %X3
  subi %r1 %n2 %r0 %X3"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "add,addi,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true,true")])


;
;  ADD4X Add Registers 
;  add4x rsa rsb rd [MODX] [ABC]
;

(define_insn "add4x"
  [(set (reg:CC REG_ESS)
	(compare:CC 
	 (plus:SI (ashift:SI
                   (match_operand:SI 1 "register_operand" "rZ") 
                   (const_int 2))
		  (match_operand:SI 2 "register_operand" "rZ"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(plus:SI (ashift:SI
		  (match_dup 1) 
		  (const_int 2))
                 (match_dup 2)))]
  ""
  "add4x %r1 %r2 %r0"
  [(set_attr "type" "arith")
   (set_attr "instruction" "add4x")
   (set_attr "octave_class" "alu3opabcmod")])

(define_insn "add4x_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(plus:SI (ashift:SI
                   (match_operand:SI 1 "register_operand" "rZ") 
                   (const_int 2))
		  (match_operand:SI 2 "register_operand" "rZ")))
   (clobber (reg:CC REG_ESS))]
  ""
  "add4x %r1 %r2 %r0"
  [(set_attr "type" "arith")
   (set_attr "instruction" "add4x")
   (set_attr "octave_class" "alu3opabcmod")])

(define_insn "add4x_lnk"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (plus:SI (ashift:SI 
                   (match_operand:SI 1 "register_operand" "rZ") 
                   (const_int 2))
		  (match_operand:SI 2 "register_operand" "rZ"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(plus:SI (ashift:SI
		  (match_dup 1) 
		  (const_int 2))
                 (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S")
        (plus:SI (ashift:SI
		  (match_dup 1) 
		  (const_int 2))
                 (match_dup 2)))]
  ""
  "add4x %r1 %r2 %r0"
  [(set_attr "type" "arith")
   (set_attr "instruction" "add4x")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true")])


(define_insn "add4x_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (plus:SI (ashift:SI 
                   (match_operand:SI 1 "register_operand" "rZ") 
                   (const_int 2))
		  (match_operand:SI 2 "register_operand" "rZ")))
   (set (match_operand:SI 3 "memory_operand" "=S")
        (plus:SI (ashift:SI
		  (match_dup 1) 
		  (const_int 2))
                 (match_dup 2)))
   (clobber (reg:CC REG_ESS))]
  ""
  "add4x %r1 %r2 %r0"
  [(set_attr "type" "arith")
   (set_attr "instruction" "add4x")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true")])

(define_insn "add4x_modx"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (plus:SI
	   (and:SI (ashift:SI 
		    (match_dup 1) 
		    (const_int 2)) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3))) 
	 (plus:SI
	  (and:SI (ashift:SI 
		   (match_dup 1) 
		   (const_int 2)) 
		  (match_dup 3))
	  (and:SI (match_dup 2) (match_dup 3)))))]
  ""
  "add4x %r1 %r2 %r0 %X3"
  [(set_attr "type" "arith")
   (set_attr "instruction" "add4x")
   (set_attr "octave_class" "alu3opabcmod")])


(define_insn "add4x_modx_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (plus:SI
	   (and:SI (ashift:SI 
		    (match_dup 1) 
		    (const_int 2)) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "add4x %r1 %r2 %r0 %X3"
  [(set_attr "type" "arith")
   (set_attr "instruction" "add4x")
   (set_attr "octave_class" "alu3opabcmod")])

(define_insn "add4x_modx_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (plus:SI
	   (and:SI (ashift:SI 
		    (match_dup 1) 
		    (const_int 2)) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3))) 
	 (plus:SI
	  (and:SI (ashift:SI 
		   (match_dup 1) 
		   (const_int 2)) 
		  (match_dup 3))
	  (and:SI (match_dup 2) 
		  (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3))) 
	 (plus:SI
	  (and:SI (ashift:SI 
		   (match_dup 1) 
		   (const_int 2)) 
		  (match_dup 3))
	  (and:SI (match_dup 2) 
		  (match_dup 3)))))]
  ""
  "add4x %r1 %r2 %r0 %X3"
  [(set_attr "type" "arith")
   (set_attr "instruction" "add4x")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])

(define_insn "add4x_modx_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_operand:SI 1 "register_operand" "rZ")
		 (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	 (plus:SI
	  (and:SI (ashift:SI 
		   (match_dup 1) 
		   (const_int 2)) 
		  (match_dup 3))
	  (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		  (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3))) 
	 (plus:SI
	  (and:SI (ashift:SI 
		   (match_dup 1) 
		   (const_int 2)) 
		  (match_dup 3))
	  (and:SI (match_dup 2) 
		  (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "add4x %r1 %r2 %r0 %X3"
  [(set_attr "type" "arith")
   (set_attr "instruction" "add4x")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])


;
;  ADDC:  Add Registers With Carry
;  ADDCI: Add Register w/ Immediate and Carry 
; 
;  addc rsa rsb rd  [MODX] [ABC]
;  addc rsa usi6 rd [MODX] [ABC]
;

(define_insn "addc"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (plus:SI (match_operand:SI 1 "register_operand" "%rZ,rZ,rZ")
		  (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	(plus:SI (match_dup 1)
		 (match_dup 2)))
   (use (reg:CC REG_ESS))]
  ""
  "@
   addc  %r1 %r2 %r0
   addci %r1 %2 %r0
   subbi %r1 %n2 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addc,addci,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")])

(define_insn "addc_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	 (plus:SI (match_operand:SI 1 "register_operand" "%rZ,rZ,rZ")
		  (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P")))
   (use (reg:CC REG_ESS))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   addc  %r1 %r2 %r0
   addci %r1 %2 %r0
   subbi %r1 %n2 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addc,addci,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")])

(define_insn "addc_lnk"
  [(set (reg:CC REG_ESS)
	(compare:CC
		 
	 (plus:SI (match_operand:SI 1 "register_operand" "%rZ,rZ,rZ")
		  (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	(plus:SI (match_dup 1)
		 (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S,S")
	(plus:SI (match_dup 1)
		 (match_dup 2)))
   (use (reg:CC REG_ESS))]
  ""
  "@
   addc  %r1 %r2 %r0
   addci %r1 %2 %r0
   subbi %r1 %n2 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addc,addci,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true,true")])

(define_insn "addc_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	(plus:SI (match_operand:SI 1 "register_operand" "%rZ,rZ,rZ")
		 (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P")))
   (set (match_operand:SI 3 "memory_operand" "=S,S,S")
	(plus:SI (match_dup 1)
		 (match_dup 2)))
   (use (reg:CC REG_ESS))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   addc  %r1 %r2 %r0
   addci %r1 %2 %r0
   subbi %r1 %n2 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addc,addci,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true,true")])


(define_insn "addc_modx"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (plus:SI (and:SI (match_dup 1) 
			   (match_dup 3))
		   (and:SI (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P") 
			   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (plus:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (use (reg:CC REG_ESS))]
  ""
  "@
   addc  %r1 %r2 %r0 %X3
   addci %r1 %2 %r0 %X3
   subbi %r1 %n2 %r0 %X3"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addc,addci,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")])


(define_insn "addc_modx_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (plus:SI (and:SI (match_dup 1) 
			   (match_dup 3))
		   (and:SI (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P") 
			   (match_dup 3)))))
   (use (reg:CC REG_ESS))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   addc  %r1 %r2 %r0 %X3
   addci %r1 %2 %r0 %X3
   subbi %r1 %n2 %r0 %X3"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addc,addci,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")])


(define_insn "addc_modx_lnk"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (plus:SI (and:SI (match_dup 1) 
			   (match_dup 3))
		   (and:SI (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P") 
			   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (plus:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S,S,S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (plus:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (use (reg:CC REG_ESS))]
  ""
  "@
   addc  %r1 %r2 %r0 %X3
   addci %r1 %2 %r0 %X3
   subbi %r1 %n2 %r0 %X3"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addc,addci,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true,true")])

(define_insn "addc_modx_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ,rZ")
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (plus:SI (and:SI (match_dup 1) 
			   (match_dup 3))
		   (and:SI (match_operand:SI 2 "reg_or_6bs_operand" "rZ,M,P") 
			   (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S,S,S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (plus:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (use (reg:CC REG_ESS))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   addc  %r1 %r2 %r0 %X3
   addci %r1 %2 %r0 %X3
   subbi %r1 %n2 %r0 %X3"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addc,addci,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true,true")])




;
; ADDL/ADDLI  Add Long
; 
; addl rsb rd 
; addl usi rd 
;

(define_expand "addl"
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_dup 0)
                 (match_operand:SI 1 "reg_or_6bs_operand" "")))]
  ""
  "
{     /* Convert a 'addl' with no branch displacement into a regular 'add' */
      emit_insn(gen_add(operands[0], operands[0], operands[1]));
      DONE;
}")

(define_expand "addl_clobber"
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_dup 0)
                 (match_operand:SI 1 "reg_or_6bs_operand" "")))]
  ""
  "
{     /* Convert a 'addl' with no branch displacement into a regular 'add' */
      emit_insn(gen_add_clobber(operands[0], operands[0], operands[1]));
      DONE;
}")

(define_expand "addl_lnk"
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_dup 0)
                 (match_operand:SI 1 "reg_or_6bs_operand" "")))
   (set (match_operand:SI 2 "memory_operand" "")
	(plus:SI (match_dup 0)
		 (match_dup 1)))]
  ""
  "
{     /* Convert a 'addl' with no branch displacement into a regular 'add' */
      emit_insn(gen_add_lnk(operands[0], operands[0], operands[1], operands[2]));
      DONE;
}")

(define_expand "addl_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "")
        (plus:SI (match_dup 0)
                 (match_operand:SI 1 "reg_or_6bs_operand" "")))
   (set (match_operand:SI 2 "memory_operand" "")
	(plus:SI (match_dup 0)
		 (match_dup 1)))]
  ""
  "
{     /* Convert a 'addl' with no branch displacement into a regular 'add' */
      emit_insn(gen_add_lnk_clobber(operands[0], operands[0], operands[1], operands[2]));
      DONE;
}")

;
; ADDL/ADDLI  Add Long
; 
; addl rsb rd br=disp
; addl usi rd br=disp
;

(define_insn "addl_br"
  [(set (pc)
	(if_then_else:SI (gt (plus:SI 
			      (match_operand:SI 0 "register_operand" "+rZ,rZ,rz") 
			      (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P"))
			     (const_int -1))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (plus:SI (match_dup 0)
                 (match_dup 1)))
   (set (reg:CC REG_ESS)
	(compare:CC 
	 (plus:SI (match_dup 0)
		  (match_dup 1))
	 (const_int 0)))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addl\");
	   return \"addl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addli\");
	   return \"addli  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subli  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addl\");
	   return \"subli  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addl,addli,subli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])



(define_insn "addl_br_clobber"
  [(set (pc)
	(if_then_else:SI (gt (plus:SI 
			      (match_operand:SI 0 "register_operand" "+rZ,rZ,rz") 
			      (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P"))
			     (const_int -1))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (plus:SI (match_dup 0)
                 (match_dup 1)))
   (clobber (reg:CC REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addl\");
	   return \"addl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addli\");
	   return \"addli  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subli  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addl\");
	   return \"subli  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addl,addli,subli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

(define_insn "addl_br_lnk"
  [(set (pc)
	(if_then_else:SI (gt (plus:SI 
			      (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ")
			      (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P"))
			     (const_int -1))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (plus:SI (match_dup 0)
                 (match_dup 1)))
   (set (reg:CC REG_ESS)
	(compare:CC
	 (plus:SI (match_dup 0)
		  (match_dup 1))
	 (const_int 0)))
   (set (match_operand:SI 3 "memory_operand" "=S,S,S")
	(plus:SI (match_dup 0)
		 (match_dup 1)))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addl\");
	   return \"addl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addli\");
	   return \"addli  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subli  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addli\");
	   return \"subli  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addl,addli,subli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])



(define_insn "addl_br_lnk_clobber"
  [(set (pc)
	(if_then_else:SI (gt (plus:SI 
			      (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ")
			      (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P"))
			     (const_int -1))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (plus:SI (match_dup 0)
                 (match_dup 1)))
   (set (match_operand:SI 3 "memory_operand" "=S,S,S")
	(plus:SI (match_dup 0)
		 (match_dup 1)))
   (clobber (reg:CC REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addl\");
	   return \"addl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addli\");
	   return \"addli  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subli  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addli\");
	   return \"subli  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addl,addli,subli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

;
;
; ADDNE/ADDNEI Add No ESS
;  
; addne rsa rsb rsd 
; addne rsa usi rsd 
;

; no conition codes set
; attr??

(define_insn "addne"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (plus:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
                 (match_operand:SI 2 "reg_or_6bu_operand" "rZ,N")))]
  ""
  "@
   addne  %r1 %r2 %r0
   addnei %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "addne,addnei")
   (set_attr "octave_class" "alu3op,alu3op")])

(define_insn "addne_lnk"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (plus:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
                 (match_operand:SI 2 "reg_or_6bu_operand" "rZ,N")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(plus:SI (match_dup 1)
		 (match_dup 2)))]
  ""
  "@
   addne  %r1 %r2 %r0
   addnei %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "addne,addnei")
   (set_attr "octave_class" "alu3op,alu3op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

;
;
; ADDWH/ADDWHI Add Word High
;  
; addwh rsb rsd 
; addwhi usi rsd
;
;

(define_insn "addwh"
  [(set (reg:CC_NOOV  REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (and:SI 
		  (match_dup 0)
		  (const_int 65535))
		 (ashift:SI (zero_extend:SI (plus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 0)))
			    (const_int 16)))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ")
        (ior:SI (and:SI 
		 (match_dup 0) 
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))]
  ""
  "@
   addwh  %r1 %r0
   addwhi %1  %r0
   subwhi %n1 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addwh,addwhi,subwhi")
   (set_attr "octave_class" "alu2op,alu2op,alu2op")])



(define_insn "addwh_clobber"
  [(set (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ")
	 (ior:SI (and:SI 
		  (match_dup 0)
		  (const_int 65535))
		 (ashift:SI (zero_extend:SI (plus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 0)))
			    (const_int 16))))
   (clobber (reg:CC_NOOV  REG_ESS))]
  ""
  "@
   addwh  %r1 %r0
   addwhi %1  %r0
   subwhi %n1 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addwh,addwhi,subwhi")
   (set_attr "octave_class" "alu2op,alu2op,alu2op")])

(define_insn "addwh_lnk"
  [(set (reg:CC_NOOV  REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (and:SI 
		  (match_dup 0)
		  (const_int 65535))
		 (ashift:SI (zero_extend:SI (plus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 0)))
			    (const_int 16)))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ")
	(ior:SI (and:SI 
		 (match_dup 0) 
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (match_operand:SI 2 "memory_operand" "=S,S,S")
	(ior:SI (and:SI 
		 (match_dup 0) 
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))]
  ""
  "@
   addwh  %r1 %r0
   addwhi %1  %r0
   subwhi %n1 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addwh,addwhi,subwhi")
   (set_attr "octave_class" "alu2op,alu2op,alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true,true,true")])



(define_insn "addwh_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ")
	(ior:SI (and:SI 
		 (match_dup 0)
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 0)))
			    (const_int 16))))
   (set (match_operand:SI 2 "memory_operand" "=S,S,S")
	(ior:SI (and:SI 
		 (match_dup 0) 
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (clobber (reg:CC_NOOV  REG_ESS))]
  ""
  "@
   addwh  %r1 %r0
   addwhi %1  %r0
   subwhi %n1 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addwh,addwhi,subwhi")
   (set_attr "octave_class" "alu2op,alu2op,alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true,true,true")])

;
;
; ADDWH/ADDWHI Add Word High
;  
; addwh rsb rsd [br=disp]
;
;


(define_insn "addwh_br"
  [(set (pc)
	(if_then_else:SI (gt:HI (plus:HI 
				 (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 0)
				 (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 0))
				(const_int 65535))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (and:SI 
		 (match_dup 0)
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (reg:CC_NOOV REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (and:SI 
		  (match_dup 0)
		  (const_int 65535))
		 (ashift:SI (zero_extend:SI (plus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16)))
	 (const_int 0)))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addwh  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwh\");
	   return \"addwh  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addwhi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwhi\");
	   return \"addwhi  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subwhi  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwhi\");
	   return \"subwhi  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addwh,addwhi,subwhi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])



(define_insn "addwh_br_clobber"
  [(set (pc)
	(if_then_else:SI (gt:HI (plus:HI 
				 (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 0)
				 (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 0))
				(const_int 65535))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (and:SI 
		 (match_dup 0)
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (clobber (reg:CC_NOOV REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addwh  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwh\");
	   return \"addwh  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addwhi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwhi\");
	   return \"addwhi  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subwhi  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwhi\");
	   return \"subwhi  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addwh,addwhi,subwhi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])


(define_insn "addwh_br_lnk"
  [(set (pc)
	(if_then_else:SI (gt:HI (plus:HI 
				 (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 0)
				 (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 0))
				(const_int 65535))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (and:SI 
		 (match_dup 0)
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (reg:CC_NOOV REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (and:SI 
		  (match_dup 0) 
		  (const_int 65535))
		 (ashift:SI (zero_extend:SI (plus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16)))
	 (const_int 0)))
   (set (match_operand:SI 3 "memory_operand" "=S,S,S")
	(ior:SI (and:SI 
		 (match_dup 0) 
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addwh  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwh\");
	   return \"addwh  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addwhi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwhi\");
	   return \"addwhi  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subwhi  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwhi\");
	   return \"subwhi  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addwh,addwhi,subwhi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])


(define_insn "addwh_br_lnk_clobber"
  [(set (pc)
	(if_then_else:SI (gt:HI (plus:HI 
				 (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 0)
				 (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 0))
				(const_int 65535))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (and:SI 
		 (match_dup 0)
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (match_operand:SI 3 "memory_operand" "=S,S,S")
	(ior:SI (and:SI 
		 (match_dup 0) 
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (clobber (reg:CC_NOOV REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addwh  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwh\");
	   return \"addwh  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addwhi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwhi\");
	   return \"addwhi  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subwhi  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwhi\");
	   return \"subwhi  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addwh,addwhi,subwhi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

;
;
; ADDWL/ADDWLI Add Word Low 
;
; addwl  rsb rsd [br=disp]
; addwli usi rsd [br=disp]
;
;

(define_insn "addwl"
  [(set (reg:CC_NOOV REG_ESS)
	(compare:CC_NOOV
	 (plus:HI (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 2)
		  (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 2))
	 (const_int 0)))
   (set (strict_low_part (subreg:HI (match_dup 0) 2))
	(plus:HI (subreg:HI (match_dup 0) 2)
		 (subreg:HI (match_dup 1) 2)))]
  ""
  "@
   addwl  %r1 %r0
   addwli %1  %r0
   subwli %n1 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addwl,addwli,subwli")
   (set_attr "octave_class" "alu2op,alu2op,alu2op")])


(define_insn "addwl_clobber"
  [(set (strict_low_part (subreg:HI (match_dup 0) 2))
	 (plus:HI (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 2)
		  (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 2)))
   (clobber (reg:CC_NOOV REG_ESS))]
  ""
  "@
   addwl  %r1 %r0
   addwli %1  %r0
   subwli %n1 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addwl,addwli,subwli")
   (set_attr "octave_class" "alu2op,alu2op,alu2op")])


(define_insn "addwl_lnk"
  [(set (reg:CC_NOOV REG_ESS)
	(compare:CC_NOOV
	 (plus:HI (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 2)
		  (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 2))
	 (const_int 0)))
   (set (strict_low_part (subreg:HI (match_dup 0) 2))
	(plus:HI (subreg:HI (match_dup 0) 2)
		 (subreg:HI (match_dup 1) 2)))
   (set (match_operand:HI 2 "memory_operand" "=S,S,S")
        (plus:HI (subreg:HI (match_dup 0) 2)
                 (subreg:HI (match_dup 1) 2)))]
  ""
  "@
   addwl  %r1 %r0
   addwli %1  %r0
   subwli %n1 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addwl,addwli,subwli")
   (set_attr "octave_class" "alu2op,alu2op,alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true,true,true")])

(define_insn "addwl_lnk_clobber"
  [(set (strict_low_part (subreg:HI (match_dup 0) 2))
	(plus:HI (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 2)
		  (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 2)))
   (set (match_operand:HI 2 "memory_operand" "=S,S,S")
        (plus:HI (subreg:HI (match_dup 0) 2)
                 (subreg:HI (match_dup 1) 2)))
   (clobber (reg:CC_NOOV REG_ESS))]
  ""
  "@
   addwl  %r1 %r0
   addwli %1  %r0
   subwli %n1 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addwl,addwli,subwli")
   (set_attr "octave_class" "alu2op,alu2op,alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true,true,true")])

;
;
; ADDWL/ADDWLI Add Word Low 
;
; addwl  rsb rsd [br=disp]
; addwli usi rsd [br=disp]
;
;

(define_insn "addwl_br"
  [(set (pc)
	(if_then_else:SI (gt (plus:HI 
			      (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 2)
			      (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 2))
			     (const_int 65535))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (strict_low_part (subreg:HI (match_dup 0) 2))
        (plus:HI (subreg:HI (match_dup 0) 2)
                 (subreg:HI (match_dup 1) 2)))
   (set (reg:CC_NOOV REG_ESS)
	(compare:CC_NOOV
	 (plus:HI (subreg:HI (match_dup 0) 2)
		  (subreg:HI (match_dup 1) 2))
	 (const_int 0)))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addwl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwl\");
	   return \"addwl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addwli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwli\");
	   return \"addwli  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subwli  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwli\");
	   return \"subwli  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addwl,addwli,subwli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])



(define_insn "addwl_br_clobber"
  [(set (pc)
	(if_then_else:SI (gt (plus:HI 
			      (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 2)
			      (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 2))
			     (const_int 65535))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (strict_low_part (subreg:HI (match_dup 0) 2))
        (plus:HI (subreg:HI (match_dup 0) 2)
                 (subreg:HI (match_dup 1) 2)))
   (clobber (reg:CC_NOOV REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addwl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwl\");
	   return \"addwl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addwli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwli\");
	   return \"addwli  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subwli  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwli\");
	   return \"subwli  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addwl,addwli,subwli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])


(define_insn "addwl_br_lnk"
  [(set (pc)
	(if_then_else:SI (gt (plus:HI 
			      (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 2)
			      (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 2))
			     (const_int 65535))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (strict_low_part (subreg:HI (match_dup 0) 2))
        (plus:HI (subreg:HI (match_dup 0) 2)
                 (subreg:HI (match_dup 1) 2)))
   (set (reg:CC_NOOV REG_ESS)
	(compare:CC_NOOV
	 (plus:HI (subreg:HI (match_dup 0) 2)
		  (subreg:HI (match_dup 1) 2))
	 (const_int 0)))
   (set (match_operand:HI 3 "memory_operand" "=S,S,S")
        (plus:HI (subreg:HI (match_dup 0) 2)
                 (subreg:HI (match_dup 1) 2)))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addwl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwl\");
	   return \"addwl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addwli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwli\");
	   return \"addwli  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subwli  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwli\");
	   return \"subwli  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addwl,addwli,subwli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])


(define_insn "addwl_br_lnk_clobber"
  [(set (pc)
	(if_then_else:SI (gt (plus:HI 
			      (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 2)
			      (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 2))
			     (const_int 65535))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (strict_low_part (subreg:HI (match_dup 0) 2))
        (plus:HI (subreg:HI (match_dup 0) 2)
                 (subreg:HI (match_dup 1) 2)))
   (set (match_operand:HI 3 "memory_operand" "=S,S,S")
        (plus:HI (subreg:HI (match_dup 0) 2)
                 (subreg:HI (match_dup 1) 2)))
   (clobber (reg:CC_NOOV REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addwl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwl\");
	   return \"addwl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addwli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwli\");
	   return \"addwli  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subwli  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwli\");
	   return \"subwli  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addwl,addwli,subwli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

;
;
; ADDWW/ADDWWI Add Two Words 
;
; addww rsb rd [br=disp]
; addwwi usi rd [br=disp]
;
;

(define_insn "addww"
  [(set (reg:CC_NOOV  REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 2) 
					  (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P")  2)))
		 (ashift:SI (zero_extend:SI (plus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16)))
	 (const_int 0)))
   (set (match_dup 0)
	(ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					 (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))]
  ""
  "@
   addww   %r1 %r0
   addwwi  %1  %r0
   subwwi  %n1 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addww,addwwi,subwwi")
   (set_attr "octave_class" "alu2op,alu2op,alu2op")])

(define_insn "addww_clobber"
  [(set (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ")
	 (ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P")  2)))
		 (ashift:SI (zero_extend:SI (plus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16))))
   (clobber (reg:CC_NOOV  REG_ESS))]
  ""
  "@
   addww   %r1 %r0
   addwwi  %1  %r0
   subwwi  %n1 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addww,addwwi,subwwi")
   (set_attr "octave_class" "alu2op,alu2op,alu2op")])

(define_insn "addww_lnk"
  [(set (reg:CC_NOOV  REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 2) 
					  (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 2)))
		 (ashift:SI (zero_extend:SI (plus:HI
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16)))
	 (const_int 0)))
   (set (match_dup 0)
	(ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					 (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (match_operand:SI 2 "memory_operand" "=S,S,S")
	(ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					 (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))]
  ""
  "@
   addww  %r1 %r0
   addwwi %1  %r0
   subwwi %n1 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addww,addwwi,subwwi")
   (set_attr "octave_class" "alu2op,alu2op,alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true,true,true")])

(define_insn "addww_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ")
	(ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 2)))
		 (ashift:SI (zero_extend:SI (plus:HI
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16))))
   (set (match_operand:SI 2 "memory_operand" "=S,S,S")
	(ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					 (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (clobber (reg:CC_NOOV  REG_ESS))]
  ""
  "@
   addww  %r1 %r0
   addwwi %1  %r0
   subwwi %n1 %r0"
  [(set_attr "type" "arith,arith,arith")
   (set_attr "instruction" "addww,addwwi,subwwi")
   (set_attr "octave_class" "alu2op,alu2op,alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true,true,true")])

;
;
; ADDWW/ADDWWI Add Two Words 
;
; addww rsb rd [br=disp]
; addwwi usi rd [br=disp]
;
;

(define_insn "addww_br"
  [(set (pc)
	(if_then_else:SI (gt (plus:HI 
			      (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 0)
			      (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 0))
			     (const_int 65535))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					 (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (reg:CC_NOOV  REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_dup 1) 2)))
		 (ashift:SI (zero_extend:SI (plus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16)))
	 (const_int 0)))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addww  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addww\");
	   return \"addww  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addwwi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwwi\");
	   return \"addwwi  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subwwi  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwwi\");
	   return \"subwwi  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addww,addwwi,subwwi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])


(define_insn "addww_br_clobber"
  [(set (pc)
	(if_then_else:SI (gt (plus:HI 
			      (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 0)
			      (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 0))
			     (const_int 65535))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					 (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (clobber (reg:CC_NOOV  REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addww  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addww\");
	   return \"addww  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addwwi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwwi\");
	   return \"addwwi  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subwwi  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwwi\");
	   return \"subwwi  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addww,addwwi,subwwi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

(define_insn "addww_br_lnk"
  [(set (pc)
	(if_then_else:SI (gt (plus:HI 
			      (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 0)
			      (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 0))
			     (const_int 65535))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					 (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (reg:CC_NOOV  REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_dup 1) 2)))
		 (ashift:SI (zero_extend:SI (plus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16)))
	 (const_int 0)))
   (set (match_operand:SI 3 "memory_operand" "=S,S,S")
        (ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					 (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addww  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addww\");
	   return \"addww  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addwwi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwwi\");
	   return \"addwwi  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subwwi  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwwi\");
	   return \"subwwi  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addww,addwwi,subwwi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

(define_insn "addww_br_lnk_clobber"
  [(set (pc)
	(if_then_else:SI (gt (plus:HI 
			      (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ,rZ") 0)
			      (subreg:HI (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M,P") 0))
			     (const_int 65535))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					 (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (match_operand:SI 3 "memory_operand" "=S,S,S")
        (ior:SI (zero_extend:SI (plus:HI (subreg:HI (match_dup 0) 2) 
					 (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (plus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (clobber (reg:CC_NOOV  REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"addww  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addww\");
	   return \"addww  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"addwwi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwwi\");
	   return \"addwwi  %1 %0\;bci %2 ESS30 %*\";
	 }

     case 2:
       if (get_attr_length(insn) == 1)
	 return \"subwwi  %n1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"addwwi\");
	   return \"subwwi  %n1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set_attr "instruction" "addww,addwwi,subwwi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

;
; AND And Registers
;
; and rsa rsb rd [MODX] [ABC]
; andi rsa simm rd [MODX] [ABC]
;

(define_insn "and"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (and:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
		 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(and:SI (match_dup 1)
		(match_dup 2)))]
  ""
  "@
  and  %r1 %r2 %r0
  andi %r1 %2 %r0"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "and,andi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")])

(define_insn "and_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (and:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
		 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
  and  %r1 %r2 %r0
  andi %r1 %2 %r0"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "and,andi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")])

(define_insn "and_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (and:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
		 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(and:SI (match_dup 1)
		(match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(and:SI (match_dup 1)
		(match_dup 2)))]
  ""
  "@
  and  %r1 %r2 %r0
  andi %r1 %2 %r0"
  [(set_attr "type" "logical,logical")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")
   (set_attr "instruction" "and,andi")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "and_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (and:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
		 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(and:SI (match_dup 1)
		(match_dup 2)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
  and  %r1 %r2 %r0
  andi %r1 %2 %r0"
  [(set_attr "type" "logical,logical")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")
   (set_attr "instruction" "and,andi")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "and_modx"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (and:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (and:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))]
  ""
  "and  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "and")
   (set_attr "octave_class" "alu3opabcmod")])


(define_insn "and_modx_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (and:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "and  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "and")
   (set_attr "octave_class" "alu3opabcmod")])

(define_insn "and_modx_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (and:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (and:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (and:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))]
  ""
  "and  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "and")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])


(define_insn "and_modx_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (and:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (and:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "and  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "and")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])



;
;  BCI: Branch Conditional Immediate
;  bci disp[15:0] [!] ess# [rd(60:62)] [C] [BF]
;
;  BCDI: Branch Conditional Delayed Immediate
;  bcdi disp[15:0] [!] ess# [rd(60:62)] [BF] [C]
;


;; CCmode

(define_insn "cbr_immed_ess_cc_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC REG_ESS) (const_int 0)])
			 (match_operand 1 "immediate_operand" "")
			 (pc)))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 0, \" %1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; CCUNSmode

(define_insn "cbr_immed_ess_ccuns_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CCUNS REG_ESS) (const_int 0)])
			 (match_operand 1 "immediate_operand" "")
			 (pc)))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 0, \" %1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; CCNOOVmode

(define_insn "cbr_immed_ess_cc_noov_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_NOOV REG_ESS) (const_int 0)])
			 (match_operand 1 "immediate_operand" "")
			 (pc)))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 0, \" %1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; CCCYmode

(define_insn "cbr_immed_ess_cc_cy_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_CY REG_ESS) (const_int 0)])
			 (match_operand 1 "immediate_operand" "")
			 (pc)))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 0, \" %1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; Conditional branch on overflow or carry

(define_insn "cbr_immed_ovr_carry"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "overflow_or_carry_ess_operand" "")
					  (const_int 1)])
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (use (reg REG_ESS))]
  ""
  "*
   return output_cbranch (REGNO(operands[1]), operands[0], 0, \" %2 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; Special Ess Register 

(define_insn "cbr_immed_spl_ess"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "spl_ess_reg_operand" "")
					  (const_int 1)])
			 (match_operand 2 "immediate_operand" "")
			 (pc)))]
  ""
  "*
   return output_cbranch (REGNO(operands[1]), operands[0], 0, \" %2 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])



;;
;; following reversed forms will be used only
;; matching, not for rtl generation
;;

;; CCmode

(define_insn "cbr_immed_ess_cc_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC REG_ESS) (const_int 0)])
			 (pc)
			 (match_operand 1 "immediate_operand" "")))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 1, \" %1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; CCUNSmode

(define_insn "cbr_immed_ess_ccuns_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CCUNS REG_ESS) (const_int 0)])
			 (pc)
			 (match_operand 1 "immediate_operand" "")))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 1, \" %1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; CCNOOVmode

(define_insn "cbr_immed_ess_cc_noov_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_NOOV REG_ESS) (const_int 0)])
			 (pc)
			 (match_operand 1 "immediate_operand" "")))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 1, \" %1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; CCCYmode

(define_insn "cbr_immed_ess_cc_cy_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_CY REG_ESS) (const_int 0)])
			 (pc)
			 (match_operand 1 "immediate_operand" "")))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 1, \" %1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;;

;; Special Ess Register

(define_insn "cbr_immed_ovr_carry_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "overflow_or_carry_ess_operand" "") 
					  (const_int 1)])
			 (pc)
			 (match_operand 2 "immediate_operand" "")))
   (use (reg REG_ESS))]
  ""
  "*
   return output_cbranch (REGNO(operands[1]), operands[0], 1, \" %2 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])


;; Special Ess Register

(define_insn "cbr_immed_spl_ess_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "spl_ess_reg_operand" "") 
					  (const_int 1)])
			 (pc)
			 (match_operand 2 "immediate_operand" "")))]
  ""
  "*
   return output_cbranch (REGNO(operands[1]), operands[0], 1, \" %2 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])


;
; Indirect conditional branch
;

;; CCmode

(define_insn "cbr_indir_ess_cc_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC REG_ESS) (const_int 0)])
			 (match_operand:SI 1 "register_operand" "rZ")
			 (pc)))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 0, \" %r1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; CCUNSmode

(define_insn "cbr_indir_ess_ccuns_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CCUNS REG_ESS) (const_int 0)])
			 (match_operand:SI 1 "register_operand" "rZ")
			 (pc)))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 0, \" %r1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; CCNOOVmode

(define_insn "cbr_indir_ess_cc_noov_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_NOOV REG_ESS) (const_int 0)])
			 (match_operand:SI 1 "register_operand" "rZ")
			 (pc)))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 0, \" %r1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; CCCYmode

(define_insn "cbr_indir_ess_cc_cy_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_CY REG_ESS) (const_int 0)])
			 (match_operand:SI 1 "register_operand" "rZ")
			 (pc)))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 0, \" %r1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; Overflow or carry

(define_insn "cbr_indir_ovr_carry"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "overflow_or_carry_ess_operand" "")
					  (const_int 1)])
			 (match_operand:SI 2 "register_operand" "rZ")
			 (pc)))
   (use (reg REG_ESS))]
  ""
  "*
   return output_cbranch (REGNO(operands[1]), operands[0], 0, \" %r2 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; Special ESS Register

(define_insn "cbr_indir_spl_ess"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "spl_ess_reg_operand" "")
					  (const_int 1)])
			 (match_operand:SI 2 "register_operand" "rZ")
			 (pc)))]
  ""
  "*
   return output_cbranch (REGNO(operands[1]), operands[0], 0, \" %r2 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])




;;
;; following reversed forms will be used only
;; matching, not for rtl generation
;;

;; CCmode

(define_insn "cbr_indir_ess_cc_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC REG_ESS) (const_int 0)])
			 (pc)
			 (match_operand:SI 1 "register_operand" "rZ")))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 1, \" %r1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; CCUNSmode

(define_insn "cbr_indir_ess_ccuns_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CCUNS REG_ESS) (const_int 0)])
			 (pc)
			 (match_operand:SI 1 "register_operand" "rZ")))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 1, \" %r1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; CCNOOVmode

(define_insn "cbr_indir_ess_cc_noov_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_NOOV REG_ESS) (const_int 0)])
			 (pc)
			 (match_operand:SI 1 "register_operand" "rZ")))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 1, \" %r1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; CCCYmode

(define_insn "cbr_indir_ess_cc_cy_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_CY REG_ESS) (const_int 0)])
			 (pc)
			 (match_operand:SI 1 "register_operand" "rZ")))]
  ""
  "*
   return output_cbranch (REG_ESS, operands[0], 1, \" %r1 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; Conditional branch indirect with overflow or carry
(define_insn "cbr_indir_ovr_carry_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "overflow_or_carry_ess_operand" "") 
					  (const_int 1)])
			 (pc)
			 (match_operand:SI 2 "register_operand" "rZ")))
   (use (reg REG_ESS))]
  ""
  "*
   return output_cbranch (REGNO(operands[1]), operands[0], 1, \" %r2 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; Special ESS Register

(define_insn "cbr_indir_spl_ess_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "spl_ess_reg_operand" "") 
					  (const_int 1)])
			 (pc)
			 (match_operand:SI 2 "register_operand" "rZ")))]
  ""
  "*
   return output_cbranch (REGNO(operands[1]), operands[0], 1, \" %r2 \", insn);"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])


;
; Conditional Call Immediate
;

;; CCmode

(define_insn "cond_call_immed_ess_cc_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC REG_ESS) (const_int 0)])
			 (call (mem:SI (match_operand:SI 1 "call_operand" ""))
			       (match_operand:SI 2 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 0,  \" %1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; CCUNSmode

(define_insn "cond_call_immed_ess_ccuns_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CCUNS REG_ESS) (const_int 0)])
			 (call (mem:SI (match_operand:SI 1 "call_operand" ""))
			       (match_operand:SI 2 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 0,  \" %1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; CCNOOVmode

(define_insn "cond_call_immed_ess_cc_noov_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_NOOV REG_ESS) (const_int 0)])
			 (call (mem:SI (match_operand:SI 1 "call_operand" ""))
			       (match_operand:SI 2 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 0,  \" %1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; CCCYmode


(define_insn "cond_call_immed_ess_cc_cy_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_CY REG_ESS) (const_int 0)])
			 (call (mem:SI (match_operand:SI 1 "call_operand" ""))
			       (match_operand:SI 2 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 0,  \" %1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

(define_insn "cond_call_ovr_carry"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "overflow_or_carry_ess_operand" "") 
					  (const_int 1)])
			 (call (mem:SI (match_operand:SI 2 "call_operand" ""))
			       (match_operand:SI 3 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 4 "register_operand" "=h"))
   (use (reg REG_ESS))]
  ""
  "*
   return output_cond_call (REGNO(operands[1]), operands[0], operands[2], 0,  \" %2 \", insn, \" %r4 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; Special ESS Register

(define_insn "cond_call_spl_ess"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "spl_ess_reg_operand" "") 
					  (const_int 1)])
			 (call (mem:SI (match_operand:SI 2 "call_operand" ""))
			       (match_operand:SI 3 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 4 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REGNO(operands[1]), operands[0], operands[2], 0,  \" %2 \", insn, \" %r4 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])




;;
;; following reversed forms will be used only
;; matching, not for rtl generation
;;


;; CCmode

(define_insn "cond_call_immed_ess_cc_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC REG_ESS) (const_int 0)])
			 (pc)
			 (call (mem:SI (match_operand:SI 1 "call_operand" ""))
			       (match_operand:SI 2 "general_operand" ""))))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 1,  \" %1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; CCUNSmode

(define_insn "cond_call_immed_ess_ccuns_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CCUNS REG_ESS) (const_int 0)])
			 (pc)
			 (call (mem:SI (match_operand:SI 1 "call_operand" ""))
			       (match_operand:SI 2 "general_operand" ""))))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 1,  \" %1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; CCNOOVmode

(define_insn "cond_call_immed_ess_cc_noov_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_NOOV REG_ESS) (const_int 0)])
			 (pc)
			 (call (mem:SI (match_operand:SI 1 "call_operand" ""))
			       (match_operand:SI 2 "general_operand" ""))))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 1,  \" %1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; CCCYmode


(define_insn "cond_call_immed_ess_cc_cy_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_CY REG_ESS) (const_int 0)])
			 (pc)
			 (call (mem:SI (match_operand:SI 1 "call_operand" ""))
			       (match_operand:SI 2 "general_operand" ""))))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 1,  \" %1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; Conditional call with overflow or carry
(define_insn "cond_call_immed_ovr_carry_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "overflow_or_carry_ess_operand" "") 
					  (const_int 1)])
			 (pc)
			 (call (mem:SI (match_operand:SI 2 "call_operand" ""))
			       (match_operand:SI 3 "general_operand" ""))))
   (clobber (match_operand:SI 4 "register_operand" "=h"))
   (use (reg REG_ESS))]
  ""
  "*
   return output_cond_call (REGNO(operands[1]), operands[0], operands[2], 1,  \" %2 \", insn, \" %r4 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;; Special ESS Register

(define_insn "cond_call_immed_spl_ess_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "spl_ess_reg_operand" "") 
					  (const_int 1)])
			 (pc)
			 (call (mem:SI (match_operand:SI 2 "call_operand" ""))
			       (match_operand:SI 3 "general_operand" ""))))
   (clobber (match_operand:SI 4 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REGNO(operands[1]), operands[0], operands[2], 1,  \" %2 \", insn, \" %r4 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bci")
   (set_attr "octave_class" "condbranchimmed")])

;
; Conditional Call Indirect
;

;; CCmode

(define_insn "cond_call_indir_ess_cc_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC REG_ESS) (const_int 0)])
			 (call (mem:SI (match_operand:SI 1 "register_operand" "rZ"))
			       (match_operand:SI 2 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 0,  \" %r1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; CCUNSmode

(define_insn "cond_call_indir_ess_ccuns_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CCUNS REG_ESS) (const_int 0)])
			 (call (mem:SI (match_operand:SI 1 "register_operand" "rZ"))
			       (match_operand:SI 2 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 0,  \" %r1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; CCNOOVmode

(define_insn "cond_call_indir_ess_cc_noov_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_NOOV REG_ESS) (const_int 0)])
			 (call (mem:SI (match_operand:SI 1 "register_operand" "rZ"))
			       (match_operand:SI 2 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 0,  \" %r1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; CCCYmode

(define_insn "cond_call_indir_ess_cc_cy_mode"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_CY REG_ESS) (const_int 0)])
			 (call (mem:SI (match_operand:SI 1 "register_operand" "rZ"))
			       (match_operand:SI 2 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 0,  \" %r1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; Conditional call indirect with carry or overflow

(define_insn "cond_call_indir_ovr_carry"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "overflow_or_carry_ess_operand" "") 
					  (const_int 1)])
			 (call (mem:SI (match_operand:SI 2 "register_operand" "rZ"))
			       (match_operand:SI 3 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 4 "register_operand" "=h"))
   (use (reg REG_ESS))]
  ""
  "*
   return output_cond_call (REGNO(operands[1]), operands[0], operands[2], 0,  \" %r2 \", insn, \" %r4 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; Special Ess Register

(define_insn "cond_call_indir_spl_ess"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "spl_ess_reg_operand" "") 
					  (const_int 1)])
			 (call (mem:SI (match_operand:SI 2 "register_operand" "rZ"))
			       (match_operand:SI 3 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 4 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REGNO(operands[1]), operands[0], operands[2], 0,  \" %r2 \", insn, \" %r4 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])




;;
;; following reversed forms will be used only
;; matching, not for rtl generation
;;


;; CCmode

(define_insn "cond_call_indir_ess_cc_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC REG_ESS) (const_int 0)])
			 (pc)
			 (call (mem:SI (match_operand:SI 1 "register_operand" "rZ"))
			       (match_operand:SI 2 "general_operand" ""))))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 1,  \" %r1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; CCUNSmode

(define_insn "cond_call_indir_ess_ccuns_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CCUNS REG_ESS) (const_int 0)])
			 (pc)
			 (call (mem:SI (match_operand:SI 1 "register_operand" "rZ"))
			       (match_operand:SI 2 "general_operand" ""))))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 1,  \" %r1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; CCNOOVmode

(define_insn "cond_call_indir_ess_cc_noov_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_NOOV REG_ESS) (const_int 0)])
			 (pc)
			 (call (mem:SI (match_operand:SI 1 "register_operand" "rZ"))
			       (match_operand:SI 2 "general_operand" ""))))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 1,  \" %r1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; CCCYmode

(define_insn "cond_call_indir_ess_cc_cy_mode_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "comparison_operator"
					 [(reg:CC_CY REG_ESS) (const_int 0)])
			 (pc)
			 (call (mem:SI (match_operand:SI 1 "register_operand" "rZ"))
			       (match_operand:SI 2 "general_operand" ""))))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REG_ESS, operands[0], operands[1], 1,  \" %r1 \", insn, \" %r3 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])


;; Conditional call indirect with overflow or carry
(define_insn "cond_call_indir_ovr_carry_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "overflow_or_carry_ess_operand" "") 
					  (const_int 1)])
			 (pc)
			 (call (mem:SI (match_operand:SI 2 "register_operand" "rZ"))
			       (match_operand:SI 3 "general_operand" ""))))
   (clobber (match_operand:SI 4 "register_operand" "=h"))
   (use (reg REG_ESS))]
  ""
  "*
   return output_cond_call (REGNO(operands[1]), operands[0], operands[2], 1,  \" %r2 \", insn, \" %r4 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])

;; Special ESS Register

(define_insn "cond_call_indir_spl_ess_rev"
  [(set (pc)
        (if_then_else:SI (match_operator 0 "spl_ess_comparison_operator"
					 [(match_operand:SI 1 "spl_ess_reg_operand" "") 
					  (const_int 1)])
			 (pc)
			 (call (mem:SI (match_operand:SI 2 "register_operand" "rZ"))
			       (match_operand:SI 3 "general_operand" ""))))
   (clobber (match_operand:SI 4 "register_operand" "=h"))]
  ""
  "*
   return output_cond_call (REGNO(operands[1]), operands[0], operands[2], 1,  \" %r2 \", insn, \" %r4 \");"
  [(set_attr "type" "cbranch")
   (set_attr "instruction" "bcr")
   (set_attr "octave_class" "condbranch")])


;
;  BI/BR: Branch Immediate/Indirect
;  bi displ[21:0] [rd(60:62)] [CD]
;  br rsa [rd(60:62)] 
;


;
; bi label_expr 
;

(define_insn "jump"
  [(set (pc) 
	(label_ref (match_operand 0 "immediate_operand" "")))]
  ""
  "bi %0 %*"
  [(set_attr "type" "branch")
   (set_attr "instruction" "bi")
   (set_attr "octave_class" "jumpop")])

;;
;; operand 0 for a "bi" pattern
;; should be a label reference
;;

(define_insn "bi"
    [(set (pc) 
	  (match_operand 0 "immediate_operand" ""))]
  ""
  "bi %0 %*"
  [(set_attr "type" "branch")
   (set_attr "instruction" "bi")
   (set_attr "octave_class" "jumpop")])


;
; bi label_expr CD
;

(define_insn "bi_cd"
  [(set (pc) (match_operand 0 "immediate_operand" ""))
   (use (const_int FLAG_CD))]
  ""
  "bi %0 CD"
  [(set_attr "type" "branch")
   (set_attr "instruction" "bi")
   (set_attr "octave_class" "jumpop")])

;
; bi label_expr RPC
; br rsa RPC
;

(define_insn "call"
  [(call (mem:SI (match_operand:SI 0 "call_operand" "r,i"))
	 ;; num of args
         (match_operand:SI 1 "general_operand" ""))
   ;; RPC
   (clobber (match_operand:SI 2 "register_operand" "=h,h"))]
  ""
  "@
   br %r0 %r2  %*
   bi %0 %r2   %*"
  [(set_attr "type" "call,call")
   (set_attr "instruction" "br,bi")
   (set_attr "octave_class" "branchop,branchop")])

;
; bi label_expr RPC CD
;

(define_insn "call_with_cd"
  [(call (mem:SI (match_operand:SI 0 "immediate_operand" ""))
	 ;; num of args
         (match_operand:SI 1 "general_operand" ""))
   (use (const_int FLAG_CD))
   ;; RPC
   (clobber (match_operand:SI 2 "register_operand" "=h"))]
  ""
  "bi %0 %2 CD %*"
  [(set_attr "type" "call")
   (set_attr "instruction" "bi")
   (set_attr "octave_class" "branchop")])


;;
;; call_value patterns.
;;

;
; bi label_expr RPC
; br rsa RPC
;

(define_insn "call_value"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(call (mem:SI (match_operand:SI 1 "call_operand" "r,i"))
	      ;; num of args
	      (match_operand:SI 2 "general_operand" "")))
   ;; RPC
   (clobber (match_operand:SI 3 "register_operand" "=h,h"))]
  ""
  "@
   br %r1 %r3  %*
   bi %1  %r3  %*"
  [(set_attr "type" "call,call")
   (set_attr "instruction" "br,bi")
   (set_attr "octave_class" "branchop,branchop")])

;
; bi label_expr RPC CD
;

(define_insn "call_value_with_cd"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(call (mem:SI (match_operand:SI 1 "immediate_operand" ""))
	      ;; num of args
	      (match_operand:SI 2 "general_operand" "")))
   (use (const_int FLAG_CD))
   ;; RPC
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "bi %1 %3 CD %*"
  [(set_attr "type" "call")
   (set_attr "instruction" "bi")
   (set_attr "octave_class" "branchop")])


;
;   BNZR/BNZI: Branch Non Zero Register/Immediate
;
;   bnzr rsa rsb
;   bnzi rsa disp[15:0]
;
;

(define_insn "bnzr"
  [(set (pc) 
        (if_then_else:SI (ne (match_operand:SI 0 "register_operand" "rZ") (const_int 0))
			 (match_operand:SI 1 "register_operand" "rZ")
			 (pc)))]
  ""
  "bnzr %r0 %r1 %<"
  [(set_attr "type" "bnzr")
   (set_attr "instruction" "bnzr")
   (set_attr "octave_class" "zerobranch")])


(define_insn "bnzi"
  [(set (pc) 
        (if_then_else:SI (ne (match_operand:SI 0 "register_operand" "rZ") (const_int 0))
			 (match_operand 1 "immediate_operand" "")
			 (pc)))]
  ""
  "bnzi %r0 %1 %<"
  [(set_attr "type" "bnzi")
   (set_attr "instruction" "bnzi")
   (set_attr "octave_class" "zerobranchimmed")])

;
; bnzr rsa rsb rd
; bnzi rsa disp rd
;



(define_insn "bnzr_call_indir"
  [(set (pc) 
        (if_then_else:SI (ne (match_operand:SI 0 "register_operand" "rZ") 
			     (const_int 0))
			 (call (mem:SI (match_operand:SI 1 "register_operand" "rZ"))
			       (match_operand:SI 2 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "bnzr %0 %1 %3 %<"
  [(set_attr "type" "bnzr")
   (set_attr "instruction" "bnzr")
   (set_attr "octave_class" "zerobranch")
   (set_attr "zerobranch_is_call" "true")])


(define_insn "bnzi_call_direct"
  [(set (pc) 
        (if_then_else:SI (ne (match_operand:SI 0 "register_operand" "rZ") 
			     (const_int 0))
			 (call (mem:SI (match_operand 1 "immediate_operand" ""))
			       (match_operand:SI 2 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "bnzi %0 %1 %3 %<"
  [(set_attr "type" "bnzi")
   (set_attr "instruction" "bnzi")
   (set_attr "octave_class" "zerobranchimmed")
   (set_attr "zerobranch_is_call" "true")])



;
; BRS
;

(define_insn "brs"
  [(set (pc) (reg:SI REG_69))]
  ""
  "brs %*"
  [(set_attr "type" "brsl")
   (set_attr "instruction" "brs")
   (set_attr "octave_class" "brtosrvc")])

(define_insn "brs_rpc"
  [(call (mem:SI (reg:SI REG_69))
	 (match_operand:SI 0 "" ""))
   (clobber (match_operand:SI 1 "register_operand" "=h"))]
  ""
  "brs %r1 %*"
  [(set_attr "type" "brsl")
   (set_attr "instruction" "brs")
   (set_attr "octave_class" "branchop")])

;
;
; BR: Branch Register Indirect
;
;

(define_insn "indirect_jump"
  [(set (pc) (match_operand:SI 0 "register_operand" "rZ"))]
  ""
  "br %r0  %*"
  [(set_attr "type" "branch")
   (set_attr "instruction" "br")
   (set_attr "octave_class" "branchop")])


;;
;; rnmi/rint 
;; jump unconditionally to _exit_

(define_insn "rnmi"
  [(unspec [(set (pc) (match_operand 0 "immediate_operand" ""))] U_RNMI)
   (use (reg:SI REG_88))]
  ""
  "rnmi %*"
  [(set_attr "type" "branch")
   (set_attr "instruction" "rnmi")
   (set_attr "octave_class" "returnop")])

(define_insn "rint"
  [(unspec [(set (pc) (match_operand 0 "immediate_operand" ""))] U_RINT)
   (use (reg:SI REG_87))]
  ""
  "rint %*"
  [(set_attr "type" "branch")
   (set_attr "instruction" "rint")
   (set_attr "octave_class" "returnop")])


;; 
;; to be used in 'c' function eplilogue
;;

(define_insn "c_return"
  [(return)
   (use (match_operand:SI 0 "register_operand" "h"))]
  ""
  "br %0 %*"
  [(set_attr "type" "branch")
   (set_attr "instruction" "br")
   (set_attr "octave_class" "branchop")])



;
;  BRS: Branch to Service Address
;

;; do we need to represent the
;; the way in which pc is modified.


;
;  BRSL: Branch to Service Address and Load
;

(define_insn "brsl"
  [(return)
   (unspec:SI [(match_operand:SI 0 "brsl_flag_operand" "")
 	       (match_operand:SI 1 "brsl_flag_operand" "")
 	       (match_operand:SI 2 "brsl_flag_operand" "")
 	       (match_operand:SI 3 "brsl_flag_operand" "")
 	       (clobber (reg:SI REG_26))
 	       (clobber (reg:SI REG_27))
 	       (clobber (reg:SI REG_28))
 	       (clobber (reg:SI REG_29))
 	       (clobber (reg:SI REG_30))
 	       (clobber (reg:SI REG_31))
 	       (clobber (reg:SI REG_32))
 	       (clobber (reg:SI REG_33))
 	       (clobber (reg:SI REG_34))
 	       (clobber (reg:SI REG_35))
 	       (clobber (reg:SI REG_36))
 	       (clobber (reg:SI REG_37))
 	       (clobber (reg:SI REG_38))
 	       (clobber (reg:SI REG_39))
	       (parallel [
			  (clobber (reg:SI REG_40))
			  (clobber (reg:SI REG_41))
			  (clobber (reg:SI REG_42))
			  (clobber (reg:SI REG_43))
			  (clobber (reg:SI REG_44))
			  (clobber (reg:SI REG_45))
			  (clobber (reg:SI REG_46))
			  (clobber (reg:SI REG_47))])
	       (parallel [
			  (clobber (reg:SI REG_48))
			  (clobber (reg:SI REG_49))
			  (clobber (reg:SI REG_50))
			  (clobber (reg:SI REG_51))
			  (clobber (reg:SI REG_52))
			  (clobber (reg:SI REG_53))
			  (clobber (reg:SI REG_54))
			  (clobber (reg:SI REG_55))
			  (clobber (reg:SI REG_56))
			  (clobber (reg:SI REG_57))
			  (clobber (reg:SI REG_58))
			  (clobber (reg:SI REG_59))])] U_BRSL)]
  ""
  "brsl %F0 %F1 %F2 %F3 %*"
  [(set_attr "type" "brsl")
   (set_attr "instruction" "brsl")
   (set_attr "octave_class" "brtosrvc")])

;
;  BRSPRE: Branch to Service Address and Load
;

(define_insn "brspre"
  [(unspec:SI [(const_int 1)] U_BRSPRE)]
  ""
  "brspre"
  [(set_attr "type" "brspre")
   (set_attr "instruction" "brspre")
   (set_attr "octave_class" "brtosrvc")])

;
;   BZR/BZRI: Branch Zero Register/Immediate
;
;   bzr rsa rsb
;   bzi rsa disp[15:0]


(define_insn "bzr"
  [(set (pc)
        (if_then_else:SI (eq (match_operand:SI 0 "register_operand" "rZ") (const_int 0))
			 (match_operand:SI 1 "register_operand" "rZ")
			 (pc)))]
  
  ""
  "bzr %r0 %r1 %<"
  [(set_attr "type" "bzr")
   (set_attr "instruction" "bzr")
   (set_attr "octave_class" "zerobranch")])

(define_insn "bzi"
  [(set (pc)
        (if_then_else:SI (eq (match_operand:SI 0 "register_operand" "rZ") (const_int 0))
			 (match_operand 1 "immediate_operand" "")
			 (pc)))]
  ""
  "bzi %0 %1 %<"
  [(set_attr "type" "bzi")
   (set_attr "instruction" "bzi")
   (set_attr "octave_class" "zerobranchimmed")])



;
; bzr rsa rsb rpc
; bzi rsa disp rpc
;


(define_insn "bzr_call_indir"
  [(set (pc) 
        (if_then_else:SI (eq (match_operand:SI 0 "register_operand" "rZ") 
			     (const_int 0))
			 (call (mem:SI (match_operand:SI 1 "register_operand" "rZ"))
			       (match_operand:SI 2 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "bzr %r0 %r1 %r3 %<"
  [(set_attr "type" "bzr")
   (set_attr "instruction" "bzr")
   (set_attr "octave_class" "zerobranch")
   (set_attr "zerobranch_is_call" "true")])

(define_insn "bzi_call_direct"
  [(set (pc) 
        (if_then_else:SI (eq (match_operand:SI 0 "register_operand" "rZ") 
			     (const_int 0))
			 (call (mem:SI (match_operand 1 "immediate_operand" ""))
			       (match_operand:SI 2 "general_operand" ""))
			 (pc)))
   (clobber (match_operand:SI 3 "register_operand" "=h"))]
  ""
  "bzi %r0 %1 %3 %<"
  [(set_attr "type" "bzi")
   (set_attr "instruction" "bzi")
   (set_attr "octave_class" "zerobranchimmed")
   (set_attr "zerobranch_is_call" "true")])


;
; BYTESW: Byte Swap
; bytesw rsa rd b0# b1# b2# b3# [ABC]
;

(define_insn "bytesw"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
        (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")
		    (match_operand:SI 2 "c2bu_operand" "")
		    (match_operand:SI 3 "c2bu_operand" "")
		    (match_operand:SI 4 "c2bu_operand" "")
		    (match_operand:SI 5 "c2bu_operand" "")] U_BYTESW))]
  ""
  "bytesw %r1 %r0 %2 %3 %4 %5"
  [(set_attr "type" "arith")
   (set_attr "instruction" "bytesw")
   (set_attr "octave_class" "aluop")])

(define_insn "bytesw_lnk"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
        (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")
		    (match_operand:SI 2 "c2bu_operand" "")
		    (match_operand:SI 3 "c2bu_operand" "")
		    (match_operand:SI 4 "c2bu_operand" "")
		    (match_operand:SI 5 "c2bu_operand" "")] U_BYTESW))
   (set (match_operand:SI 6 "memory_operand" "=S")
	(unspec:SI [(match_dup 1)
		    (match_dup 2)
		    (match_dup 3)
		    (match_dup 4)
		    (match_dup 5)] U_BYTESW))]
  ""
  "bytesw %r1 %r0 %2 %3 %4 %5"
  [(set_attr "type" "arith")
   (set_attr "instruction" "bytesw")
   (set_attr "octave_class" "aluop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[6])"))
   (set_attr "linked_mem_update" "true")])


;
;  CLRB: Clear Bit
;  clrb rsa rsb rd 
;

(define_insn "clrb"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		 (not:SI (ashift:SI (const_int 1) 
				    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))))

	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(and:SI (match_dup 1)
		(not:SI (ashift:SI (const_int 1) 
				   (match_dup 2)))))]
  ""
  "@
   clrb  %r1 %r2 %r0
   clrbi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "clrb,clrbi")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])


(define_insn "clrb_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		 (not:SI (ashift:SI (const_int 1) 
				    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   clrb  %r1 %r2 %r0
   clrbi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "clrb,clrbi")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])


(define_insn "clrb_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		 (not:SI (ashift:SI (const_int 1) 
				    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(and:SI (match_dup 1)
		(not:SI (ashift:SI (const_int 1) 
				   (match_dup 2)))))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(and:SI (match_dup 1)
		(not:SI (ashift:SI (const_int 1) 
				   (match_dup 2)))))
   ]
  ""
  "@
   clrb  %r0 %r1 %r2
   clrbi %r0 %r1 %r2"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "clrb,clrbi")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "clrb_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		 (not:SI (ashift:SI (const_int 1) 
				    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(and:SI (match_dup 1)
		(not:SI (ashift:SI (const_int 1) 
				   (match_dup 2)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   clrb  %r0 %r1 %r2
   clrbi %r0 %r1 %r2"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "clrb,clrbi")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])



;
; CMOV/CMOVI Conditional Move
; 
; cmov rsa rsb rd [!] ess#
; cmov rsa usi rd [!] ess#
;

;
; cmov patterns for generic flags
; ESS_OVERFLOW, ESS_CARRY, ESS_GT, ESS_LT, ESS_EQ
;


; nolink 

(define_insn "cmov_ess_cc_mode"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "comparison_operator"
					 [(reg:CC REG_ESS) (const_int 0)])
                         (match_operand:SI 2 "register_operand" "rZ,rZ")
                         (match_operand:SI 3 "reg_or_6bu_operand" "rZ,M")))]
  ""
  "@
  cmov  %2 %r3 %0 %C1
  cmovi %2 %3 %0 %C1"
  [(set_attr "type" "cond_move,cond_move")
   (set_attr "instruction" "cmov,cmovi")
   (set_attr "octave_class" "cmovop,cmovop")])

(define_insn "cmov_ess_ccuns_mode"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "comparison_operator"
					 [(reg:CCUNS REG_ESS) (const_int 0)])
                         (match_operand:SI 2 "register_operand" "rZ,rZ")
                         (match_operand:SI 3 "reg_or_6bu_operand" "rZ,M")))]
  ""
  "@
  cmov  %2 %r3 %0 %C1
  cmovi %2 %3 %0 %C1"
  [(set_attr "type" "cond_move,cond_move")
   (set_attr "instruction" "cmov,cmovi")
   (set_attr "octave_class" "cmovop,cmovop")])


(define_insn "cmov_ess_cc_cy_mode"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "comparison_operator"
					 [(reg:CC_CY REG_ESS) (const_int 0)])
                         (match_operand:SI 2 "register_operand" "rZ,rZ")
                         (match_operand:SI 3 "reg_or_6bu_operand" "rZ,M")))]
  ""
  "@
  cmov  %2 %r3 %0 %C1
  cmovi %2 %3 %0 %C1"
  [(set_attr "type" "cond_move,cond_move")
   (set_attr "instruction" "cmov,cmovi")
   (set_attr "octave_class" "cmovop,cmovop")])

(define_insn "cmov_ess_cc_noov_mode"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "comparison_operator"
					 [(reg:CC_NOOV REG_ESS) (const_int 0)])
                         (match_operand:SI 2 "register_operand" "rZ,rZ")
                         (match_operand:SI 3 "reg_or_6bu_operand" "rZ,M")))]
  ""
  "@
  cmov  %2 %r3 %0 %C1
  cmovi %2 %3 %0 %C1"
  [(set_attr "type" "cond_move,cond_move")
   (set_attr "instruction" "cmov,cmovi")
   (set_attr "octave_class" "cmovop,cmovop")])

;
; cmov patterns with lnk 
;

(define_insn "cmov_lnk_ess_cc_mode"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "comparison_operator"
					 [(reg:CC REG_ESS) (const_int 0)])
                         (match_operand:SI 2 "register_operand" "rZ,rZ")
                         (match_operand:SI 3 "reg_or_6bu_operand" "rZ,M")))
   (set (match_operand:SI 4 "memory_operand" "=S,S")
	(if_then_else:SI (match_op_dup 1 [(reg:CC REG_ESS) (const_int 0)])
			 (match_dup 2)
			 (match_dup 3)))]
  ""
  "@
  cmov  %2 %r3 %0 %C1
  cmovi %2 %3 %0 %C1"
  [(set_attr "type" "cond_move,cond_move")
   (set_attr "instruction" "cmov,cmovi")
   (set_attr "octave_class" "cmovop,cmovop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "cmov_lnk_ess_ccuns_mode"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "comparison_operator"
					 [(reg:CCUNS REG_ESS) (const_int 0)])
                         (match_operand:SI 2 "register_operand" "rZ,rZ")
                         (match_operand:SI 3 "reg_or_6bu_operand" "rZ,M")))
   (set (match_operand:SI 4 "memory_operand" "=S,S")
	(if_then_else:SI (match_op_dup 1 [(reg:CC REG_ESS) (const_int 0)])
			 (match_dup 2)
			 (match_dup 3)))]
  ""
  "@
  cmov  %2 %r3 %0 %C1
  cmovi %2 %3 %0 %C1"
  [(set_attr "type" "cond_move,cond_move")
   (set_attr "instruction" "cmov,cmovi")
   (set_attr "octave_class" "cmovop,cmovop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "cmov_lnk_ess_cc_cy_mode"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "comparison_operator"
					 [(reg:CC_CY REG_ESS) (const_int 0)])
                         (match_operand:SI 2 "register_operand" "rZ,rZ")
                         (match_operand:SI 3 "reg_or_6bu_operand" "rZ,M")))
   (set (match_operand:SI 4 "memory_operand" "=S,S")
	(if_then_else:SI (match_op_dup 1 [(reg:CC REG_ESS) (const_int 0)])
			 (match_dup 2)
			 (match_dup 3)))]
  ""
  "@
  cmov  %2 %r3 %0 %C1
  cmovi %2 %3 %0 %C1"
  [(set_attr "type" "cond_move,cond_move")
   (set_attr "instruction" "cmov,cmovi")
   (set_attr "octave_class" "cmovop,cmovop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true")])



(define_insn "cmov_lnk_ess_cc_noov_mode"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "comparison_operator"
					 [(reg:CC_NOOV REG_ESS) (const_int 0)])
                         (match_operand:SI 2 "register_operand" "rZ,rZ")
                         (match_operand:SI 3 "reg_or_6bu_operand" "rZ,M")))
   (set (match_operand:SI 4 "memory_operand" "=S,S")
	(if_then_else:SI (match_op_dup 1 [(reg:CC REG_ESS) (const_int 0)])
			 (match_dup 2)
			 (match_dup 3)))]
  ""
  "@
  cmov  %2 %r3 %0 %C1
  cmovi %2 %3 %0 %C1"
  [(set_attr "type" "cond_move,cond_move")
   (set_attr "instruction" "cmov,cmovi")
   (set_attr "octave_class" "cmovop,cmovop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true")])

;;
;; cmov with overflow or carry
;;

(define_insn "cmov_ovr_carry"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "spl_ess_comparison_operator"
					 [(match_operand:SI 2 "overflow_or_carry_ess_operand" "")
					  (const_int 1)])
                         (match_operand:SI 3 "register_operand" "rZ,rZ")
                         (match_operand:SI 4 "reg_or_6bu_operand" "rZ,M")))
   (use (reg REG_ESS))]
  ""
  "*
   return output_cmov_spl(\" %0 \", operands[1], operands[2], \" %3 \", operands[4]);" 
  [(set_attr "type" "cond_move,cond_move")
   (set_attr "instruction" "cmov,cmovi")
   (set_attr "octave_class" "cmovop,cmovop")])

(define_insn "cmov_ovr_carry_lnk"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "spl_ess_comparison_operator"
					 [(match_operand 2 "overflow_or_carry_ess_operand" "")
					  (const_int 1)])
                         (match_operand:SI 3 "register_operand" "rZ,rZ")
                         (match_operand:SI 4 "reg_or_6bu_operand" "rZ,M")))
   (set (match_operand:SI 5 "memory_operand" "=S,S")
	(if_then_else:SI (match_op_dup 1 [(match_dup 2) 
					  (const_int 1)])
			 (match_dup 3)
			 (match_dup 4)))
   (use (reg REG_ESS))]
  ""
  "*
   return output_cmov_spl(\" %0 \", operands[1], operands[2], \" %3 \", operands[4]);"
  [(set_attr "type" "cond_move,cond_move")
   (set_attr "instruction" "cmov,cmovi")
   (set_attr "octave_class" "cmovop,cmovop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true")])

;
; cmov patterns for special ESS flag
;

(define_insn "cmov_spl_ess"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "spl_ess_comparison_operator"
					 [(match_operand:SI 2 "spl_ess_reg_operand" "")
					  (const_int 1)])
                         (match_operand:SI 3 "register_operand" "rZ,rZ")
                         (match_operand:SI 4 "reg_or_6bu_operand" "rZ,M")))]
  ""
  "*
   return output_cmov_spl(\" %0 \", operands[1], operands[2], \" %3 \", operands[4]);" 
  [(set_attr "type" "cond_move,cond_move")
   (set_attr "instruction" "cmov,cmovi")
   (set_attr "octave_class" "cmovop,cmovop")])

(define_insn "cmov_spl_ess_lnk"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "spl_ess_comparison_operator"
					 [(match_operand 2 "spl_ess_reg_operand" "")
					  (const_int 1)])
                         (match_operand:SI 3 "register_operand" "rZ,rZ")
                         (match_operand:SI 4 "reg_or_6bu_operand" "rZ,M")))
   (set (match_operand:SI 5 "memory_operand" "=S,S")
	(if_then_else:SI (match_op_dup 1 [(match_dup 2) 
					  (const_int 1)])
			 (match_dup 3)
			 (match_dup 4)))]
  ""
  "*
   return output_cmov_spl(\" %0 \", operands[1], operands[2], \" %3 \", operands[4]);"
  [(set_attr "type" "cond_move,cond_move")
   (set_attr "instruction" "cmov,cmovi")
   (set_attr "octave_class" "cmovop,cmovop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true")])

;
; CMP/CMPI Conditional Move
;
; cmp  rsa rsb rd 
; cmpi rsa usi rd 
;

(define_insn "cmp"
  [(set (reg:CCUNS REG_ESS)
        (compare:CCUNS (match_operand:SI 0 "register_operand" "rZ,rZ")
                       (match_operand:SI 1 "reg_or_10bs_operand" "rZ,T")))]
  ""
  "@
  cmp  %r0 %r1 
  cmpi %r0 %1"
  [(set_attr "type" "compare,compare")
   (set_attr "instruction" "cmp,cmpi")
   (set_attr "octave_class" "compareop,compareop")])


;
; cmp rsa rsb br=disp ABC
;


(define_insn "cmp_br"
  [(set (pc)
        (if_then_else:SI (match_operator 2 "comparison_operator"
					 [(match_operand:SI 0 "register_operand" "rZ,rZ")
					  (match_operand:SI 1 "reg_or_10bs_operand" "rZ,T")])
			 (match_operand 3 "immediate_operand" "")
			 (pc)))
   (set (reg:CCUNS REG_ESS)
        (compare:CCUNS (match_dup 0)
                       (match_dup 1)))]
  ""
  "@
  cmp  %r0 %r1 br=%3 %B2 %>
  cmpi %r0 %1 br=%3 %B2 %>"
  [(set_attr "type" "cmp_br,cmpi_br")
   (set_attr "instruction" "cmp,cmpi")
   (set_attr "octave_class" "compareop,compareop")])



(define_insn "cmp_br_clobber"
  [(set (pc)
        (if_then_else:SI (match_operator 2 "comparison_operator"
					 [(match_operand:SI 0 "register_operand" "rZ,rZ")
					  (match_operand:SI 1 "reg_or_10bs_operand" "rZ,T")])
			 (match_operand 3 "immediate_operand" "")
			 (pc)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
  cmp  %r0 %r1 br=%3 %B2 %>
  cmpi %r0 %1 br=%3 %B2 %>"
  [(set_attr "type" "cmp_br,cmpi_br")
   (set_attr "instruction" "cmp,cmpi")
   (set_attr "octave_class" "compareop,compareop")])


;
; CMPR/CMPRI: Compare Two Registers and Load Register  
;
; cmpr rsa rsb rd [ABC] [SIGN]
; cmpri rsa usb rd [ABC] [SIGN]
;

(define_insn "cmpr_signed"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (match_operand:SI 2 "register_operand" "rZ,rZ") 
	 (match_operand:SI 3 "reg_or_10bs_operand" "rZ,T")))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "comparison_operator"
					 [(match_dup 2)
					  (match_dup 3)])
			 (const_int 1)
			 (const_int 0)))
   (use (const_int FLAG_SIGN))]
  ""
  "@
  cmpr  %r2 %r3 %r0 %B1 SIGN
  cmpri %r2 %3 %r0 %B1 SIGN"
  [(set_attr "type" "compare,compare")
   (set_attr "instruction" "cmpr,cmpri")
   (set_attr "octave_class" "compareopsign,compareopsign")])


(define_insn "cmpr_signed_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "comparison_operator"
					 [(match_operand:SI 2 "register_operand" "rZ,rZ")
					  (match_operand:SI 3 "reg_or_10bs_operand" "rZ,T")])
			 (const_int 1)
			 (const_int 0)))
   (clobber (reg:CCUNS REG_ESS))
   (use (const_int FLAG_SIGN))]
  ""
  "@
  cmpr  %r2 %r3 %r0 %B1 SIGN
  cmpri %r2 %3 %r0 %B1 SIGN"
  [(set_attr "type" "compare,compare")
   (set_attr "instruction" "cmpr,cmpri")
   (set_attr "octave_class" "compareopsign,compareopsign")])


(define_insn "cmpr_unsigned"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (match_operand:SI 2 "register_operand" "rZ,rZ")
	 (match_operand:SI 3 "reg_or_10bs_operand" "rZ,T")))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "comparison_operator"
					 [(match_dup 2)
					  (match_dup 3)])
			 (const_int 1)
			 (const_int 0)))]
  ""
  "@
  cmpr  %r2 %r3 %r0 %B1
  cmpri %r2 %3 %r0 %B1"
  [(set_attr "type" "compare,compare")
   (set_attr "instruction" "cmpr,cmpri")
   (set_attr "octave_class" "compareop,compareop")])


(define_insn "cmpr_unsigned_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (if_then_else:SI (match_operator 1 "comparison_operator"
					 [(match_operand:SI 2 "register_operand" "rZ,rZ")
					  (match_operand:SI 3 "reg_or_10bs_operand" "rZ,T")])
			 (const_int 1)
			 (const_int 0)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
  cmpr  %r2 %r3 %r0 %B1
  cmpri %r2 %3 %r0 %B1"
  [(set_attr "type" "compare,compare")
   (set_attr "instruction" "cmpr,cmpri")
   (set_attr "octave_class" "compareop,compareop")])

;
;
; NOTE: if PR6479 is resolved and it turns out
; that cmpr causes implicit memory updates then we
; need to have additional patterns here.
;
;

;
;
; DEPB: Deposit Bit Field from Register to Register
; depb rsb rsb-bit# rd rd-bit# #bits
;

(define_insn "depb"
  [(set (match_operand:SI 0 "register_operand" "+rZ")
	(ior:SI 
; voodoo on dst
	 (and:SI (match_dup 0)
		 (not:SI (lshiftrt:SI 
			  (ashift:SI (const_int -1)
				     (minus:SI (const_int 32)
; #bits
					       (match_operand:SI 1 "c5bu_operand" "L")))
			  (minus:SI (const_int 32)
; rd-bit#
				    (minus:SI (match_operand:SI 2 "c5bu_operand" "L")
					      (match_dup 1))))))
; voodo on src
	 (ashift:SI (zero_extract:SI (match_operand:SI 3 "register_operand" "rZ")
; size: #bits
				     (match_dup 1)
; position: rsb-bit#
				     (match_operand:SI 4 "nibble_operand" ""))
		    (match_dup 2))))]
  ""
  "depb %r3 %4 %r0 %2 %1"
  [(set_attr "type" "depb")
   (set_attr "instruction" "depb")
   (set_attr "octave_class" "bitop")])
   
(define_insn "depb_lnk"
  [(set (match_operand:SI 0 "register_operand" "+rZ")
	(ior:SI 
	 (and:SI (match_dup 0)
		 (not:SI (lshiftrt:SI 
			  (ashift:SI (const_int -1)
				     (minus:SI (const_int 32)
					       (match_operand:SI 1 "c5bu_operand" "L")))
			  (minus:SI (const_int 32)
				    (minus:SI (match_operand:SI 2 "c5bu_operand" "L")
					      (match_dup 1))))))
	 (ashift:SI (zero_extract:SI (match_operand:SI 3 "register_operand" "rZ")
				     (match_dup 1)
				     (match_operand:SI 4 "nibble_operand" ""))
		    (match_dup 2))))
   (set (match_operand:SI 5 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 0)
		 (not:SI (lshiftrt:SI 
			  (ashift:SI (const_int -1)
				     (minus:SI (const_int 32)
					       (match_dup 1)))
			  (minus:SI (const_int 32)
				    (minus:SI (match_dup 2)
					      (match_dup 1))))))
	 (ashift:SI (zero_extract:SI (match_dup 3)
				     (match_dup 1)
				     (match_dup 4))
		    (match_dup 2))))]
  ""
  "depb %r3 %4 %r0 %2 %1"
  [(set_attr "type" "depb")
   (set_attr "instruction" "depb")
   (set_attr "octave_class" "bitop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[5])"))
   (set_attr "linked_mem_update" "true")])


;
; depb rsb rsb-bit# rd rd-bit# #bits Z
;


(define_insn "depb_z"
  [ (set (match_operand:SI 0 "register_operand" "+rZ")
	 (ior:SI
; clear rd
	  (xor:SI (match_dup 0)
		  (match_dup 0))
; extract rsb
	  (ashift:SI (zero_extract:SI (match_operand:SI 1 "register_operand" "rZ")
				      (match_operand:SI 2 "c5bu_operand" "L")
				      (match_operand:SI 3 "nibble_operand" ""))
		     (match_operand:SI 4 "c5bu_operand" "L"))))]
  ""
  "depb %r1 %3 %r0 %4 %2 Z"
  [(set_attr "type" "depb")
   (set_attr "instruction" "depb")
   (set_attr "octave_class" "bitop")])
    
	    


(define_insn "depb_z_lnk"
  [ (set (match_operand:SI 0 "register_operand" "+rZ")
	 (ior:SI
	  (xor:SI (match_dup 0)
		  (match_dup 0))
	  (ashift:SI (zero_extract:SI (match_operand:SI 1 "register_operand" "rZ")
				      (match_operand:SI 2 "c5bu_operand" "L")
				      (match_operand:SI 3 "nibble_operand" ""))
		     (match_operand:SI 4 "c5bu_operand" "L"))))
    (set (match_operand:SI 5 "memory_operand" "=S")
	 (ior:SI
	  (xor:SI (match_dup 0)
		  (match_dup 0))
	  (ashift:SI (zero_extract:SI (match_dup 1)
				      (match_dup 2)
				      (match_dup 3))
		     (match_dup 4))))]
  ""
  "depb %r1 %3 %r0 %4 %2 Z"
  [(set_attr "type" "depb")
   (set_attr "instruction" "depb")
   (set_attr "octave_class" "bitop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[5])"))
   (set_attr "linked_mem_update" "true")])
    
	    



;
; depbi usi9 rd rd-bit# #bits
;

(define_insn "depbi"
  [ (set (match_operand:SI 0 "register_operand" "+rZ")
	 (ior:SI
; voodo on rd
	  (and:SI (match_dup 0)
		  (not:SI (lshiftrt:SI (ashift:SI (const_int -1)
						  (minus:SI (const_int 32)
; #bits
							    (match_operand:SI 1 "c5bu_operand" "L")))
				       (minus:SI (const_int 32)
; rd-bit#
						 (minus:SI (match_operand:SI 2 "c5bu_operand" "L")
							   (match_dup 1))))))
; voodo on usi
	  (ashift:SI (zero_extract:SI (match_operand:SI 3 "c9bu_operand" "O")
				      (match_dup 1)
				      (const_int 0))
		     (match_dup 2)))) ]
  ""
  "depbi %3 %r0 %2 %1"
  [(set_attr "type" "depbi")
   (set_attr "instruction" "depbi")
   (set_attr "octave_class" "bitopimmed")])




(define_insn "depbi_lnk"
  [ (set (match_operand:SI 0 "register_operand" "+rZ")
	 (ior:SI
	  (and:SI (match_dup 0)
		  (not:SI (lshiftrt:SI (ashift:SI (const_int -1)
						  (minus:SI (const_int 32)
							    (match_operand:SI 1 "c5bu_operand" "L")))
				       (minus:SI (const_int 32)
						 (minus:SI (match_operand:SI 2 "c5bu_operand" "L")
							   (match_dup 1))))))
	  (ashift:SI (zero_extract:SI (match_operand:SI 3 "c9bu_operand" "O")
				      (match_dup 1)
				      (const_int 0))
		     (match_dup 2))))     
    (set (match_operand:SI 4 "memory_operand" "=S")
	 (ior:SI
	  (and:SI (match_dup 0)
		  (not:SI (lshiftrt:SI (ashift:SI (const_int -1)
						  (minus:SI (const_int 32)
							    (match_dup 1)))
				       (minus:SI (const_int 32)
						 (minus:SI (match_dup 2)
							   (match_dup 1))))))
	  (ashift:SI (zero_extract:SI (match_dup 3)
				      (match_dup 1)
				      (const_int 0))
		     (match_dup 2))))]
  ""
  "depbi %3 %r0 %2 %1"
  [(set_attr "type" "depbi")
   (set_attr "instruction" "depbi")
   (set_attr "octave_class" "bitopimmed")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])


;
; depbi usi9 rd rd-bit# #bits Z
;

(define_insn "depbi_z"
  [ (set (match_operand:SI 0 "register_operand" "+rZ")
	 (ior:SI
	  (xor:SI (match_dup 0)
		  (match_dup 0))
	  (ashift:SI
	   (zero_extract:SI (match_operand:SI 1 "c9bu_operand" "O")
			    (match_operand:SI 2 "c5bu_operand" "L")
			    (const_int 0))
	   (match_operand:SI 3 "c5bu_operand" "L")))) ]
  ""
  "depbi %1 %r0 %3 %2 Z"
  [(set_attr "type" "depbi")
   (set_attr "instruction" "depbi")
   (set_attr "octave_class" "bitopimmed")])
			    
		  

(define_insn "depbi_z_lnk"
  [ (set (match_operand:SI 0 "register_operand" "+rZ")
	 (ior:SI
	  (xor:SI (match_dup 0)
		  (match_dup 0))
	  (ashift:SI
	   (zero_extract:SI (match_operand:SI 1 "c9bu_operand" "O")
			    (match_operand:SI 2 "c5bu_operand" "L")
			    (const_int 0))
	   (match_operand:SI 3 "c5bu_operand" "L")))) 
    (set (match_operand:SI 4 "memory_operand" "=S")
	 (ior:SI
	  (xor:SI (match_dup 0)
		  (match_dup 0))
	  (ashift:SI
	   (zero_extract:SI (match_dup 1)
			    (match_dup 2)
			    (const_int 0))
	   (match_dup 3))))]
  ""
  "depbi %1 %r0 %3 %2 Z"
  [(set_attr "type" "depbi")
   (set_attr "instruction" "depbi")
   (set_attr "octave_class" "bitopimmed")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])
			    
		  


;
;
;  dmap rsa-rsa+1 dmaflags
;

(define_insn "dmap"
  [ (unspec:SI 
     [(match_operand:DI 0 "register_operand" "rZ")
      (match_operand:SI 1 "const_int_operand" "")] U_DMAP)
    (use (reg:SI REG_107))
    (use (reg:SI REG_108))
    (use (reg:SI REG_109))
    (clobber (mem:BLK (match_scratch 2 "X")))]
  ""
  "dmap %r0 %1"
  [(set_attr "type" "dma")
   (set_attr "instruction" "dmap")
   (set_attr "octave_class" "dmaop")])


;
;  DMASR: CCRAM srDMA
;

(define_insn "dmasr"
  [ (unspec:SI 
     [(match_operand:DI 0 "register_operand" "rZ")
      (match_operand:SI 1 "const_int_operand" "")] U_DMASR)
    (use (reg:SI REG_107))
    (use (reg:SI REG_108))
    (use (reg:SI REG_109))
    (clobber (mem:BLK (match_scratch 2 "X")))]
  ""
  "dmasr %r0 %1"
  [(set_attr "type" "dma")
   (set_attr "instruction" "dmasr")
   (set_attr "octave_class" "dmaop")])


;
;  DMAU0: CCRAM u0DMA
;
;

(define_insn "dmau0"
  [ (unspec:SI 
     [(match_operand:DI 0 "register_operand" "rZ")
      (match_operand:SI 1 "const_int_operand" "")] U_DMAU0)
    (use (reg:SI REG_107))
    (use (reg:SI REG_108))
    (use (reg:SI REG_109))
    (clobber (mem:BLK (match_scratch 2 "X")))]
  ""
  "dmau0 %r0 %1"
  [(set_attr "type" "dma")
   (set_attr "instruction" "dmau0")
   (set_attr "octave_class" "dmaop")])


;
;  DMAU1: CCRAM u1DMA1
;

(define_insn "dmau1"
  [ (unspec:SI 
     [(match_operand:DI 0 "register_operand" "rZ")
      (match_operand:SI 1 "const_int_operand" "")] U_DMAU1)
    (use (reg:SI REG_107))
    (use (reg:SI REG_108))
    (use (reg:SI REG_109))
    (clobber (mem:BLK (match_scratch 2 "X")))]
  ""
  "dmau1 %r0 %1"
  [(set_attr "type" "dma")
   (set_attr "instruction" "dmau1")
   (set_attr "octave_class" "dmaop")])


;
;  EXTB: Extract Bit Field from Register to Register
;  extb rsb rsb-bit# rd rd-bit# #bits


(define_insn "extb"
  [(set (match_operand:SI  0 "register_operand" "+rZ")
	(ior:SI 
; voodo on rd
	 (and:SI (match_dup 0)
		 (lshiftrt:SI (const_int -1)
			      (minus:SI (const_int 32)
; rd-bit#
					(match_operand:SI 1 "nibble_operand" ""))))
; voodo on rsb
	 (ashift:SI (zero_extract:SI (match_operand:SI 2 "register_operand" "rZ")
; #bits
				     (match_operand:SI 3 "c5bu_operand" "L")
; rsb-bit#
				     (match_operand:SI 4 "c5bu_operand" "L"))
		    (match_dup 1))))]
  ""
  "extb %r2 %4 %r0 %1 %3"
  [(set_attr "type" "extb")
   (set_attr "instruction" "extb")
   (set_attr "octave_class" "bitop")])



(define_insn "extb_lnk"
  [(set (match_operand:SI  0 "register_operand" "+rZ")
	(ior:SI 
	 (and:SI (match_dup 0)
		 (lshiftrt:SI (const_int -1)
			      (minus:SI (const_int 32)
					(match_operand:SI 1 "nibble_operand" ""))))
	 (ashift:SI (zero_extract:SI (match_operand:SI 2 "register_operand" "rZ")
				     (match_operand:SI 3 "c5bu_operand" "L")
				     (match_operand:SI 4 "c5bu_operand" "L"))
		    (match_dup 1))))
   (set (match_operand:SI 5 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 0)
		 (lshiftrt:SI (const_int -1)
			      (minus:SI (const_int 32)
					(match_dup 1))))
	 (ashift:SI (zero_extract:SI (match_dup 2)
				     (match_dup 3)
				     (match_dup 4))
		    (match_dup 1))))]
  ""
  "extb %r2 %4 %r0 %1 %3"
  [(set_attr "type" "extb")
   (set_attr "instruction" "extb")
   (set_attr "octave_class" "bitop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[5])"))
   (set_attr "linked_mem_update" "true")])



;
; extb rsb rsb-bit# rd rd-bit# #bits SIGN
;

(define_insn "extb_sign"
  [(set (match_operand:SI 0 "register_operand" "+rZ")
	(ior:SI (match_dup 0)
; voodo on rsb
		(ashiftrt:SI 
		 (ashift:SI (zero_extract:SI (match_operand:SI 1 "register_operand" "rZ")
; #bits
					     (match_operand:SI 2 "c5bu_operand" "L")
; rsb-bit#
					     (match_operand:SI 3 "c5bu_operand" "L"))
			    (minus:SI (const_int 32)
				      (match_dup 3)))
		 (minus:SI (const_int 32)
; rd-bit#
			   (minus:SI (match_operand:SI 4 "nibble_operand" "")
				     (match_dup 3))))))]
  ""
  "extb %r1 %3 %r0 %4 %2 SIGN"
  [(set_attr "type" "extb")
   (set_attr "instruction" "extb")
   (set_attr "octave_class" "bitop")])

(define_insn "extb_sign_lnk"
  [ (set (match_operand:SI 0 "register_operand" "+rZ")
	 (ior:SI (match_dup 0)
		 (ashiftrt:SI 
		  (ashift:SI (zero_extract:SI (match_operand:SI 1 "register_operand" "rZ")
					      (match_operand:SI 2 "c5bu_operand" "L")
					      (match_operand:SI 3 "c5bu_operand" "L"))
			     (minus:SI (const_int 32)
				       (match_dup 3)))
		  (minus:SI (const_int 32)
			    (minus:SI (match_operand:SI 4 "nibble_operand" "")
				      (match_dup 3)))))) 
    (set (match_operand:SI 5 "memory_operand" "=S")
	 (ior:SI (match_dup 0)
		 (ashiftrt:SI 
		  (ashift:SI (zero_extract:SI (match_dup 1)
					      (match_dup 2)
					      (match_dup 3))
			     (minus:SI (const_int 32)
				       (match_dup 3)))
		  (minus:SI (const_int 32)
			    (minus:SI (match_dup 4)
				      (match_dup 3))))))]
  ""
  "extb %r1 %3 %r0 %4 %2 SIGN"
  [(set_attr "type" "extb")
   (set_attr "instruction" "extb")
   (set_attr "octave_class" "bitop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[5])"))
   (set_attr "linked_mem_update" "true")])



;
; FFS: Find First Bit Set
; ffs rsa rd [ABC] [ZB]
;

(define_insn "ffs"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ffs:SI (match_operand:SI 1 "register_operand" "rZ"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ffs:SI (match_dup 1)))]
  ""
  "ffs  %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "ffs")
   (set_attr "octave_class" "alu2opfind")])


(define_insn "ffs_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (ffs:SI (match_operand:SI 1 "register_operand" "rZ")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "ffs  %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "ffs")
   (set_attr "octave_class" "alu2opfind")])


(define_insn "ffs_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ffs:SI (match_operand:SI 1 "register_operand" "rZ"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ffs:SI (match_dup 1)))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(ffs:SI (match_dup 1)))]
  ""
  "ffs  %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "ffs")
   (set_attr "octave_class" "alu2opfind")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])

(define_insn "ffs_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (ffs:SI (match_operand:SI 1 "register_operand" "rZ")))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(ffs:SI (match_dup 1)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "ffs  %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "ffs")
   (set_attr "octave_class" "alu2opfind")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])


;
; ffs rsa rd ZB
;


(define_insn "ffs_zb"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS 
	 (unspec:SI [(ffs:SI (match_operand:SI 1 "register_operand" "rZ"))] U_FFS)
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(ffs:SI (match_dup 1))] U_FFS))]
  ""
  "ffs  %r1 %r0 ZB"
  [(set_attr "type" "logical")
   (set_attr "instruction" "ffs")
   (set_attr "octave_class" "alu2opfind")])

(define_insn "ffs_zb_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (unspec:SI [(ffs:SI (match_operand:SI 1 "register_operand" "rZ"))] U_FFS))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "ffs  %r1 %r0 ZB"
  [(set_attr "type" "logical")
   (set_attr "instruction" "ffs")
   (set_attr "octave_class" "alu2opfind")])

(define_insn "ffs_zb_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (unspec:SI [(ffs:SI (match_operand:SI 1 "register_operand" "rZ"))] U_FFS)
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(ffs:SI (match_dup 1))] U_FFS))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(unspec:SI [(ffs:SI (match_dup 1))] U_FFS))]
  ""
  "ffs  %r1 %r0 ZB"
  [(set_attr "type" "logical")
   (set_attr "instruction" "ffs")
   (set_attr "octave_class" "alu2opfind")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])

(define_insn "ffs_zb_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (unspec:SI [(ffs:SI (match_operand:SI 1 "register_operand" "rZ"))] U_FFS))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(unspec:SI [(ffs:SI (match_dup 1))] U_FFS))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "ffs  %r1 %r0 ZB"
  [(set_attr "type" "logical")
   (set_attr "instruction" "ffs")
   (set_attr "octave_class" "alu2opfind")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])


;
;  FLS: Find Last Bit Set
;  (can we expand this instead of unspec?
;    would that help?)


(define_insn "fls"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_FLS)
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(match_dup 1)] U_FFS))]
  ""
  "ffs  %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "fls")
   (set_attr "octave_class" "alu2opfind")])


(define_insn "fls_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_FLS))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "ffs  %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "fls")
   (set_attr "octave_class" "alu2opfind")])


(define_insn "fls_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_FLS)
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(match_dup 1)] U_FFS))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(unspec:SI [(match_dup 1)] U_FFS))]
  ""
  "fls  %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "fls")
   (set_attr "octave_class" "alu2opfind")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])

(define_insn "fls_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_FLS))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(unspec:SI [(match_dup 1)] U_FFS))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "fls  %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "fls")
   (set_attr "octave_class" "alu2opfind")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])

;
; fls ZB
;


(define_insn "fls_zb"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_FLS_ZB)
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(match_dup 1)] U_FLS_ZB))]
  ""
  "fls  %r1 %r0 ZB"
  [(set_attr "type" "logical")
   (set_attr "instruction" "fls")
   (set_attr "octave_class" "alu2opfind")])

(define_insn "fls_zb_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_FLS_ZB))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "fls  %r1 %r0 ZB"
  [(set_attr "type" "logical")
   (set_attr "instruction" "fls")
   (set_attr "octave_class" "alu2opfind")])

(define_insn "fls_zb_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_FLS_ZB)
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(match_dup 1)] U_FLS_ZB))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(unspec:SI [(match_dup 1)] U_FLS_ZB))]
  ""
  "fls  %r1 %r0 ZB"
  [(set_attr "type" "logical")
   (set_attr "instruction" "fls")
   (set_attr "octave_class" "alu2opfind")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])

(define_insn "fls_zb_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_FLS_ZB))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(unspec:SI [(match_dup 1)] U_FLS_ZB))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "fls  %r1 %r0 ZB"
  [(set_attr "type" "logical")
   (set_attr "instruction" "fls")
   (set_attr "octave_class" "alu2opfind")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])


;
;  GET: Get Last Connection
;

(define_insn "get_v31"
  [ (unspec:SI [(match_operand:SI 0  "register_operand" "rZ")
		(match_operand:SI 1  "get_flag_operand" "")
		(match_operand:SI 2  "get_flag_operand" "")
		(match_operand:SI 3  "get_flag_operand" "")
		(match_operand:SI 4  "get_flag_operand" "")
		(match_operand:SI 5  "get_flag_operand" "")
		(match_operand:SI 6  "get_flag_operand" "")
		(match_operand:SI 7  "get_flag_operand" "")
		(match_operand:SI 8  "get_flag_operand" "")
		(match_operand:SI 9  "get_flag_operand" "")] U_GET)
    (use (reg:SI REG_110))
    (clobber (mem:BLK (match_scratch 10 "X")))]
  ""
  "get %r0 %F1 %F2 %F3 %F4 %F5 %F6 %F7 %F8 %F9"
  [(set_attr "type" "get")
   (set_attr "instruction" "get")
   (set_attr "octave_class" "tssrcop")])

(define_insn "get_v4"
  [(unspec:SI [(set (reg:SI REG_TSS_GET_PTR)
		    (unspec:SI [(match_operand:SI 0  "register_operand" "rZ")
				(match_operand:SI 1  "get_flag_operand" "")
				(match_operand:SI 2  "get_flag_operand" "")
				(match_operand:SI 3  "get_flag_operand" "")
				(match_operand:SI 4  "get_flag_operand" "")
				(match_operand:SI 5  "get_flag_operand" "")
				(match_operand:SI 6  "get_flag_operand" "")
				(match_operand:SI 7  "get_flag_operand" "")
				(match_operand:SI 8  "get_flag_operand" "")
				(match_operand:SI 9  "get_flag_operand" "")
				(match_operand:SI 10  "get_flag_operand" "")
				(match_operand:SI 11  "get_flag_operand" "")] U_GET))
	       (use (reg:SI REG_110))] U_GET_WRAPPER)]
  ""
  "get %r0 %F1 %F2 %F3 %F4 %F5 %F6 %F7 %F8 %F9 %F10 %F11"
  [(set_attr "type" "get")
   (set_attr "instruction" "get")
   (set_attr "octave_class" "tssrcop")])

;;(define_insn "get_v4"
;;  [(unspec:SI [(match_operand:SI 0  "register_operand" "rZ")
;;	       (match_operand:SI 1  "get_flag_operand" "")
;;	       (match_operand:SI 2  "get_flag_operand" "")
;;	       (match_operand:SI 3  "get_flag_operand" "")
;;	       (match_operand:SI 4  "get_flag_operand" "")
;;	       (match_operand:SI 5  "get_flag_operand" "")
;;	       (match_operand:SI 6  "get_flag_operand" "")
;;	       (match_operand:SI 7  "get_flag_operand" "")
;;	       (match_operand:SI 8  "get_flag_operand" "")
;;	       (match_operand:SI 9  "get_flag_operand" "")
;;	       (match_operand:SI 10  "get_flag_operand" "")
;;	       (match_operand:SI 11  "get_flag_operand" "")] U_GET)
;;   (use (reg:SI REG_110))
;;   (clobber (mem:BLK (match_scratch 12 "X")))]
;;  ""
;;  "get %r0 %F1 %F2 %F3 %F4 %F5 %F6 %F7 %F8 %F9 %F10 %F11"
;;  [(set_attr "type" "get")
;;   (set_attr "instruction" "get")
;;   (set_attr "octave_class" "tssrcop")])



;
;  HEC5: Header Checksum
;


(define_insn "hec5"
  [ (set (reg:CCUNS REG_ESS)
	 (compare:CCUNS
	  (unspec:SI [ (match_operand:SI 1 "register_operand" "rZ")
		       (match_operand:SI 2 "c3bu_operand" "K")
		       (match_operand:SI 3 "hec5_flag_operand" "")] U_HEC5) 
	  (const_int 0)))
    (set (match_operand:SI 0 "register_operand" "=rZ")
	 (unspec:SI [ (match_dup 1)
		      (match_dup 2)
		      (match_dup 3)] U_HEC5))]
  ""
  "hec5 %r1 %r0 %2 %F3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "hec5")
   (set_attr "octave_class" "octave")])

		      
(define_insn "hec5_clobber"
  [ (set (match_operand:SI 0 "register_operand" "=rZ")
	 (unspec:SI [ (match_operand:SI 1 "register_operand" "rZ")
		       (match_operand:SI 2 "c3bu_operand" "K")
		       (match_operand:SI 3 "hec5_flag_operand" "")] U_HEC5))
    (clobber (reg:CCUNS REG_ESS))]
  ""
  "hec5 %r1 %r0 %2 %F3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "hec5")
   (set_attr "octave_class" "octave")])

		      
(define_insn "hec5_lnk"
  [ (set (reg:CCUNS REG_ESS)
	 (compare:CCUNS
	  (unspec:SI [ (match_operand:SI 1 "register_operand" "rZ")
		       (match_operand:SI 2 "c3bu_operand" "K")
		       (match_operand:SI 3 "hec5_flag_operand" "")] U_HEC5) 
	  (const_int 0)))
    (set (match_operand:SI 4 "memory_operand" "=S")
	 (unspec:SI [ (match_dup 1)
		      (match_dup 2)
		      (match_dup 3)] U_HEC5))
    (set (match_operand:SI 0 "register_operand" "=rZ")
	 (unspec:SI [ (match_dup 1)
		      (match_dup 2)
		      (match_dup 3)] U_HEC5))]
  ""
  "hec5 %r1 %r0 %2 %F3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "hec5")
   (set_attr "octave_class" "octave")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])

		      
(define_insn "hec5_lnk_clobber"
  [ (set (match_operand:SI 0 "register_operand" "=rZ")
	  (unspec:SI [ (match_operand:SI 1 "register_operand" "rZ")
		       (match_operand:SI 2 "c3bu_operand" "K")
		       (match_operand:SI 3 "hec5_flag_operand" "")] U_HEC5))
    (set (match_operand:SI 4 "memory_operand" "=S")
	 (unspec:SI [ (match_dup 1)
		      (match_dup 2)
		      (match_dup 3)] U_HEC5))
    (clobber (reg:CCUNS REG_ESS))]
  ""
  "hec5 %r1 %r0 %2 %F3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "hec5")
   (set_attr "octave_class" "octave")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])

;
;
; hec5 br
;
;

(define_insn "hec5_br"
  [(set (pc)
	(if_then_else:SI (gt (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")
					 (match_operand:SI 2 "c3bu_operand" "K")
					 (match_operand:SI 3 "hec5_flag_operand" "")] U_HEC5)
			     (const_int -1))
			 (match_operand 4 "immediate_operand" "")
			 (pc)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(match_dup 1)
		    (match_dup 2)
		    (match_dup 3)] U_HEC5) )
   (set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (unspec:SI [(match_dup 1)
		     (match_dup 2)
		     (match_dup 3)] U_HEC5)
	 (const_int 0)))]
  ""
  "hec5 %r1 %r0 %2 %F3 br=%4 %*"
  [(set_attr "type" "hec5_branch")
   (set_attr "instruction" "hec5")
   (set_attr "octave_class" "octave")])
		      
(define_insn "hec5_br_clobber"
  [(set (pc)
	(if_then_else:SI (gt (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")
					 (match_operand:SI 2 "c3bu_operand" "K")
					 (match_operand:SI 3 "hec5_flag_operand" "")] U_HEC5)
			     (const_int -1))
			 (match_operand 4 "immediate_operand" "")
			 (pc)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(match_dup 1)
		    (match_dup 2)
		    (match_dup 3)] U_HEC5) )
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "hec5 %r1 %r0 %2 %F3 br=%4 %*"
  [(set_attr "type" "hec5_branch")
   (set_attr "instruction" "hec5")
   (set_attr "octave_class" "octave")])
		      

(define_insn "hec5_br_lnk"
  [(set (pc)
	(if_then_else:SI (gt (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")
					 (match_operand:SI 2 "c3bu_operand" "K")
					 (match_operand:SI 3 "hec5_flag_operand" "")] U_HEC5)
			     (const_int -1))
			 (match_operand 4 "immediate_operand" "")
			 (pc)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [ (match_dup 1)
		     (match_dup 2)
		     (match_dup 3)] U_HEC5) )
   (set (match_operand:SI 5 "memory_operand" "=S")
	(unspec:SI [ (match_dup 1)
		     (match_dup 2)
		     (match_dup 3)] U_HEC5))
   (set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (unspec:SI [ (match_dup 1)
		      (match_dup 2)
		      (match_dup 3)] U_HEC5)
	 (const_int 0)))]
  ""
  "hec5 %r1 %r0 %2 %F3 br=%4 %*"
  [(set_attr "type" "hec5_branch")
   (set_attr "instruction" "hec5")
   (set_attr "octave_class" "octave")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[5])"))
   (set_attr "linked_mem_update" "true")])


(define_insn "hec5_br_lnk_clobber"
  [(set (pc)
	(if_then_else:SI (gt (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")
					 (match_operand:SI 2 "c3bu_operand" "K")
					 (match_operand:SI 3 "hec5_flag_operand" "")] U_HEC5)
			     (const_int -1))
			 (match_operand 4 "immediate_operand" "")
			 (pc)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [ (match_dup 1)
		     (match_dup 2)
		     (match_dup 3)] U_HEC5) )
   (set (match_operand:SI 5 "memory_operand" "=S")
	(unspec:SI [ (match_dup 1)
		     (match_dup 2)
		     (match_dup 3)] U_HEC5))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "hec5 %r1 %r0 %2 %F3 br=%4 %*"
  [(set_attr "type" "hec5_branch")
   (set_attr "instruction" "hec5")
   (set_attr "octave_class" "octave")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[5])"))
   (set_attr "linked_mem_update" "true")])



		                        
;
; LAIH: Load And Add Immediate High
;

(define_insn "laih"
  [(set (match_operand:SI 0 "register_operand" "+rZ")
        (plus:SI (match_dup 0)
                 (unspec:SI [(match_operand:SI 1 "immediate_operand" "i")] U_LAIH)))]
  ""
  "laih %r0 %Y1"
  [(set_attr "type" "laih")
   (set_attr "instruction" "laih")
   (set_attr "octave_class" "loadop")])


(define_insn "laih_lnk"
  [(set (match_operand:SI 0 "register_operand" "+rZ")
        (plus:SI (match_dup 0)
                 (unspec:SI [(match_operand:SI 1 "immediate_operand" "i")] U_LAIH)))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(plus:SI (match_dup 0)
                 (unspec:SI [(match_dup 1)] U_LAIH)))]
  ""
  "laih %r0 %Y1"
  [(set_attr "type" "laih")
   (set_attr "instruction" "laih")
   (set_attr "octave_class" "loadop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])




;
;  LIH: Load Immediate High
;

(define_insn "lih"
  [(set (match_operand:SI 0 "register_operand" "=re")
        (unspec:SI [(match_operand:SI 1 "symbol_or_16bu_operand" "")] U_LIH))]
  ""
  "lih  %0 %1"
  [(set_attr "type" "lih")
   (set_attr "instruction" "lih")
   (set_attr "octave_class" "loadop")])


(define_insn "lih_lnk"
  [(set (match_operand:SI 0 "register_operand" "=re")
        (unspec:SI [(match_operand:SI 1 "symbol_or_16bu_operand" "")] U_LIH))
   (set (match_operand:SI 2 "memory_operand" "=S")
        (unspec:SI [(match_dup 1)] U_LIH))]
  ""
  "lih %r0 %Y1"
  [(set_attr "type" "lih")
   (set_attr "instruction" "lih")
   (set_attr "octave_class" "loadop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])



;
; LAIL: Load And Add Immediate Low
;

(define_insn "lail"
  [(set (match_operand:SI 0 "register_operand" "+rZ")
	(lo_sum:SI (match_dup 0)
		   (match_operand:SI 1 "immediate_operand" "i")))]
  ""
  "lail %r0 %Y1"
  [(set_attr "type" "lail")
   (set_attr "instruction" "lail")
   (set_attr "octave_class" "loadop")])

(define_insn "lail_lnk"
  [(set (match_operand:SI 0 "register_operand" "+rZ")
	(lo_sum:SI (match_dup 0)
		   (match_operand:SI 1 "immediate_operand" "i")))
   (set (match_operand:SI 2 "memory_operand" "=S")
    	(lo_sum:SI (match_dup 0)
		   (match_dup 1)))]
  ""
  "lail %r0 %Y1"
  [(set_attr "type" "lail")
   (set_attr "instruction" "lail")
   (set_attr "octave_class" "loadop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])



;
;
;  LIL: Load Immediate Low
;

(define_insn "lil"
  [(set (match_operand:SI 0 "register_operand" "=re")
        (unspec:SI [(match_operand:SI 1 "immediate_operand"  "i")] U_LIL))]
  ""
  "lil %r0 %Y1"
  [(set_attr "type" "lil")
   (set_attr "instruction" "lil")
   (set_attr "octave_class" "loadop")])


(define_insn "lil_lnk"
  [(set (match_operand:SI 0 "register_operand" "=re")
        (unspec:SI [(match_operand:SI 1 "immediate_operand"  "i")] U_LIL))
   (set (match_operand:SI 2 "memory_operand" "=S")
        (unspec:SI [(match_dup 1)] U_LIL))]
  ""
  "lil %r0 %Y1"
  [(set_attr "type" "lil")
   (set_attr "instruction" "lil")
   (set_attr "octave_class" "loadop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])

;
; link rd1-rd2 BASE2 uimm12 LNK1|LNK2|LNK3
;

(define_insn "link_base2_indirect"
  [(match_parallel 0 "any_operand" 
		   [(unspec:SI [(set (match_operand:SI 1 "lnk_register_operand" "=l") 
				     (minus:SI (plus:SI (reg:SI REG_BASE2)
							(match_operand:SI 2 "symbol_or_12bu_operand" ""))
					       (match_operand:SI 3 "const_int_operand" "")))] U_LINK)
		    (use (match_operand:SI 4 "register_operand" "r"))])]
  ""
  "*
  {
    int words = XVECLEN (operands[0], 0);
    operands[5] = gen_rtx (REG, SImode, REGNO (operands[4]) + words - 2);
    return \"link  %4-%5 BASE2 %2 %1\";
  }"
  [(set_attr "type" "link")
   (set_attr "instruction" "link")
   (set_attr "octave_class" "multilink")])


;
; link rd1-rd2 BASE3 uimm12 [LNK1|LNK2|LNK3]
;

(define_insn "link_base3_indirect"
  [(match_parallel 0 "any_operand" 
		   [(unspec:SI [(set (match_operand:SI 1 "lnk_register_operand" "=l") 
				     (minus:SI (plus:SI (reg:SI REG_BASE3)
							(match_operand:SI 2 "symbol_or_12bu_operand" ""))
					       (match_operand:SI 3 "const_int_operand" "")))] U_LINK)
		    (use (match_operand:SI 4 "register_operand" "r"))])]
  ""
  "*
  {
    int words = XVECLEN (operands[0], 0);
    operands[5] = gen_rtx (REG, SImode, REGNO (operands[4]) + words - 2);
    return \"link  %4-%5 BASE3 %2 %1\";
  }"
  [(set_attr "type" "link")
   (set_attr "instruction" "link")
   (set_attr "octave_class" "multilink")])


;
; link rd1-rd2 simm(rsa) LNK1|LNK2|LNK3
;

(define_insn "link_reg_offset_indirect"
  [(match_parallel 0 "any_operand" 
		   [(unspec:SI [(set (match_operand:SI 1 "lnk_register_operand" "=l") 
				     (minus:SI (plus:SI (match_operand:SI 2 "register_operand" "rZ")
							(match_operand:SI 3 "const_int_operand" ""))
					       (match_operand:SI 4 "const_int_operand" "")))] U_LINK)
		    (use (match_operand:SI 5 "register_operand" "r"))])]
  ""
  "*
  {
    int words = XVECLEN (operands[0], 0);
    operands[6] = gen_rtx (REG, SImode, REGNO (operands[5]) + words - 2);
    return \"link  %5-%6 %3(%2) %1\";
  }"
  [(set_attr "type" "link")
   (set_attr "instruction" "link")
   (set_attr "octave_class" "multilink")])


;
; links rd1-rd2 0(rsa) LNK1|LNK2|LNK3
; links rd1-rd2 simm(rsa) LNK1|LNK2|LNK3
;


(define_insn "links_reg_offset_indirect"
  [(match_parallel 0 "any_operand" 
		   [(unspec:SI [(set (match_operand:SI 1 "lnk_register_operand" "=l") 
				     (minus:SI (plus:SI (match_operand:SI 2 "register_operand" "rZ")
							(match_operand:SI 3 "const_int_operand" ""))
					       (match_operand:SI 4 "const_int_operand" "")))] U_LINKS)
		    (use (match_operand:SI 5 "register_operand" "r"))])]
  ""
  "*
  {
    int words = XVECLEN (operands[0], 0);
    operands[6] = gen_rtx (REG, SImode, REGNO (operands[5]) + words - 2);
    return \"links  %5-%6 %3(%2) %1\";
  }"
  [(set_attr "type" "link")
   (set_attr "instruction" "link")
   (set_attr "octave_class" "multilink")])

;;
;; single word move pattern...
;;

;
; Single Reg load/store Insns
;
; lmm rd1-rd2 rsb              [LNK1|LNK2|LNK3]
; lmm rd1-rd2 0(rsb)           [LNK1|LNK2|LNK3]
; lmm rd1-rd2 BASE2 label_expr [LNK1|LNK2|LNK3]
; lmm rd1-rd2 BASE3 label_expr [LNK1|LNK2|LNK3]
;

(define_insn "movsi_insn"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,e,r,m")
	(match_operand:SI 1 "move_operand"  "rZ,R,e,r,m,rZ"))]
  ""
  "*
{
  switch (which_alternative)
    {
    case 0:
      return \"cmov	%r1 %r1 %r0 ESS_BRALWAYS \";

    case 1:
      if (CONST_OK_FOR_UI_17BITS (INTVAL (operands[1])))
	return \"lil	%r0 %1\";
      else
	return \"lih	%r0 hi16(%1)\";

    case 2:
      return \"mvhr     %1 %0\";

    case 3:
      return \"mvrh     %1 %0\";

    case 4:
      return output_lmm(operands[0], operands[1], \" %0-%0 \", \" %1 \");

    case 5:
      return output_smm(operands[0], operands[1], \" %1-%1 \", \" %0 \");

    default:
      return \"movsi_insn: invalid alternative\"; 
    }
}"
  [(set_attr "type" "cond_move,lil_or_lih,mvhr,mvrh,lmm,smm")
   (set_attr "mem_transfer_size" "0,0,0,0,1,1")
   (set_attr "instruction" "cmov,lil,mvhr,mvrh,lmm,smm")
   (set_attr "octave_class" "cmovop,loadop,mvhop,mvhop,singleload,singlestore")
   (set (attr "memory_region")
	(cond [(eq_attr "alternative" "4") (symbol_ref "memory_region_p (operands[1])")
	       (eq_attr "alternative" "5") (symbol_ref "memory_region_p (operands[0])")]
	      (const_string "none")))])
;
;  LMM: Load Multiple Memory
;
;
; lmm rd1-rd2 rsb              [LNK1|LNK2|LNK3]
; lmm rd1-rd2 0(rsb)           [LNK1|LNK2|LNK3]
; lmm rd1-rd2 BASE2 label_expr [LNK1|LNK2|LNK3]
; lmm rd1-rd2 BASE3 label_expr [LNK1|LNK2|LNK3]
;

(define_insn "lmm_single_with_lnk"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(match_operand:SI 1 "memory_operand" "m"))
   (set (match_operand:SI 2 "lnk_register_operand" "=l") 
	(minus:SI (match_dup 1)
		  (mult:SI (match_operand:SI 3 "lnk_offset_operand" "")
			   (const_int 4))))]
  ""
  "*
  {
   return output_lmm_with_lnk (operands[0], operands[1], \" %0-%0 \", \" %1 \", \" %2\");
  }"
  [(set_attr "type" "lmm")
   (set_attr "instruction" "lmm")
   (set_attr "octave_class" "singleload")
   (set_attr "mem_transfer_size" "1")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[1])"))
   (set_attr "reg_linked_to_mem" "true")])


(define_insn "lmm_multiple"
  [(match_parallel 0 "load_multiple_operation"
		   [(set (match_operand:SI 1 "register_operand" "=rZ")
			 (match_operand:SI 2 "memory_operand" "m"))])]
  ""
  "*
  {
   unsigned int words = XVECLEN (operands[0], 0);
   operands[3] = gen_rtx_REG(SImode, REGNO (operands[1]) + words - 1);
   return output_lmm (operands[1], operands[2], \" %1-%3 \", \" %2 \");
  }"
  [(set_attr "type" "lmm")
   (set_attr "instruction" "lmm")
   (set_attr "octave_class" "multiload")
   (set (attr "odd_register_multiload")
	(symbol_ref "odd_register_p (operands[1])"))
   (set (attr "mem_transfer_size")
        (cond [(eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 2))
	       (const_string "2")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 3))
	       (const_string "3")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 4))
	       (const_string "4")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 5))
	       (const_string "5")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 6))
	       (const_string "6")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 7))
	       (const_string "7")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 8))
	       (const_string "8")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 9))
	       (const_string "9")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 10))
	       (const_string "10")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 11))
	       (const_string "11")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 12))
	       (const_string "12")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 13))
	       (const_string "13")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 14))
	       (const_string "14")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 15))
	       (const_string "15")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 16))
	       (const_string "16")]
	      (const_string "1")))
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))])


(define_insn "lmm_multiple_with_lnk"
  [(match_parallel 0 "load_multiple_operation"
		   [(set (match_operand:SI 1 "register_operand" "=rZ")
			 (match_operand:SI 2 "memory_operand" "m"))])
   (set (match_operand:SI 3 "lnk_register_operand" "=l") 
	(minus:SI (match_operand:SI 4 "memory_operand" "m")
		  (mult:SI (match_operand:SI 5 "lnk_offset_operand" "")
			   (const_int 4))))]
  ""
  "*
  {
   unsigned int words = XVECLEN (operands[0], 0);
   operands[6] = gen_rtx_REG(SImode, REGNO (operands[1]) + words - 1);
   return output_lmm_with_lnk (operands[1], operands[2], \" %1-%6 \", \" %2 \", \" %3\");
  }"
  [(set_attr "type" "lmm")
   (set_attr "instruction" "lmm")
   (set_attr "octave_class" "multiload")
   (set (attr "odd_register_multiload")
	(symbol_ref "odd_register_p (operands[1])"))
   (set (attr "mem_transfer_size")
        (cond [(eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 2))
	       (const_string "2")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 3))
	       (const_string "3")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 4))
	       (const_string "4")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 5))
	       (const_string "5")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 6))
	       (const_string "6")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 7))
	       (const_string "7")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 8))
	       (const_string "8")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 9))
	       (const_string "9")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 10))
	       (const_string "10")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 11))
	       (const_string "11")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 12))
	       (const_string "12")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 13))
	       (const_string "13")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 14))
	       (const_string "14")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 15))
	       (const_string "15")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 16))
	       (const_string "16")]
	      (const_string "1")))
   (set_attr "reg_linked_to_mem" "true")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))])

;
;  SMM: Store Multiple Memory
;
;
; smm rd1-rd2 rsb              
; smm rd1-rd2 0(rsb)           
; smm rd1-rd2 BASE2 label_expr 
; smm rd1-rd2 BASE3 label_expr 
;


(define_insn "smm_multiple"
  [(match_parallel 0 "store_multiple_operation"
		   [(set (match_operand:SI 1 "memory_operand" "=m")
			 (match_operand:SI 2 "register_operand" "rZ"))])]
  ""
  "*
  {
   unsigned int words = XVECLEN (operands[0], 0);
   operands[3] = gen_rtx_REG(SImode, REGNO (operands[2]) + words - 1);
   return output_smm (operands[1], operands[2], \" %2-%3 \", \" %1 \");
  }"
  [(set_attr "type" "smm")
   (set_attr "instruction" "smm")
   (set_attr "octave_class" "multistore")
   (set (attr "odd_register_multistore")
	(symbol_ref "odd_register_p (operands[1])"))
   (set (attr "mem_transfer_size")
        (cond [(eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 2))
	       (const_string "2")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 3))
	       (const_string "3")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 4))
	       (const_string "4")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 5))
	       (const_string "5")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 6))
	       (const_string "6")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 7))
	       (const_string "7")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 8))
	       (const_string "8")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 9))
	       (const_string "9")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 10))
	       (const_string "10")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 11))
	       (const_string "11")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 12))
	       (const_string "12")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 13))
	       (const_string "13")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 14))
	       (const_string "14")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 15))
	       (const_string "15")
	       (eq (symbol_ref "XVECLEN (operands[0],0)") (const_int 16))
	       (const_string "16")]
	      (const_string "1")))
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[1])"))])



;
;   LWIH: Load Word Immediate High
;

(define_insn "lwih"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
        (unspec:SI [(match_operand:SI 1 "symbol_or_16bu_operand" "")] U_LWIH))]
  ""
  "lwih  %r0 %1"
  [(set_attr "type" "lwih")
   (set_attr "instruction" "lwih")
   (set_attr "octave_class" "loadop")])


(define_insn "lwih_lnk"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
        (unspec:SI [(match_operand:SI 1 "symbol_or_16bu_operand" "")] U_LWIH))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(match_dup 1))]
  ""
  "lwih  %r0 %1"
  [(set_attr "type" "lwih")
   (set_attr "instruction" "lwih")
   (set_attr "octave_class" "loadop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])

;
;   LWIL: Load Word Immediate Low
;


(define_insn "lwil"
  [(set (strict_low_part (subreg:HI (match_operand:SI 0 "register_operand" "=rZ") 2))
        (unspec:HI [(match_operand:SI 1 "symbol_or_16bu_operand" "")] U_LWIL))]
  ""
  "lwil  %0 %1"
  [(set_attr "type" "lwil")
   (set_attr "instruction" "lwil")
   (set_attr "octave_class" "loadop")])


(define_insn "lwil_lnk"
  [(set (strict_low_part (subreg:HI (match_operand:SI 0 "register_operand" "=rZ") 2))
        (unspec:HI [(match_operand:SI 1 "symbol_or_16bu_operand" "")] U_LWIL))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(match_dup 1))]
  ""
  "lwil  %0 %1"
  [(set_attr "type" "lwil")
   (set_attr "instruction" "lwil")
   (set_attr "octave_class" "loadop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])


;
;   MAX: Maximum of Two Registers
;
;   max rsa rsb rd [MODX] [ABC]
;   maxi rsa simm rd [ABC]
;

(define_insn "max"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (umax:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(umax:SI (match_dup 1)
		 (match_dup 2)))]
  ""
  "@
   max  %r1 %r2 %r0
   maxi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "max,maxi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")])

(define_insn "max_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (umax:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   max  %r1 %r2 %r0
   maxi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "max,maxi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")])

(define_insn "max_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (umax:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(umax:SI (match_dup 1)
		 (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(umax:SI (match_dup 1)
		 (match_dup 2)))]
  ""
  "@
   max  %r1 %r2 %r0
   maxi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "max,maxi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "max_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (umax:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(umax:SI (match_dup 1)
		 (match_dup 2)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   max  %r1 %r2 %r0
   maxi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "max,maxi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])


;
;   MAX: Maximum of Two Registers
;
;   max rsa rsb rd [MODX] [ABC]
;   maxi rsa simm rd [ABC]
;


(define_insn "max_modx"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (umax:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (umax:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))]
  ""
  "max  %r1 %r2 %r0 %X3"
  [(set_attr "type" "arith")
   (set_attr "instruction" "max")
   (set_attr "octave_class" "alu3opabcmod")])

(define_insn "max_modx_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (umax:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "max  %r1 %r2 %r0 %X3"
  [(set_attr "type" "arith")
   (set_attr "instruction" "max")
   (set_attr "octave_class" "alu3opabcmod")])

(define_insn "max_modx_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (umax:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (umax:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (umax:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))]
  ""
  "max  %r1 %r2 %r0 %X3"
  [(set_attr "type" "arith")
   (set_attr "instruction" "max")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])

(define_insn "max_modx_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (umax:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (umax:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "max  %r1 %r2 %r0 %X3"
  [(set_attr "type" "arith")
   (set_attr "instruction" "max")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])


;
;   MIN: Minimum of Two Registers
;
;  min rsa rsb rd [MODX] [ABC]
;  mini rsa simm rd [ABC]
;

(define_insn "min"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (umin:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(umin:SI (match_dup 1)
		 (match_dup 2)))]
  ""
  "@
   min  %r1 %r2 %r0
   mini %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "min,mini")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")])

(define_insn "min_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (umin:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   min  %r1 %r2 %r0
   mini %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "min,mini")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")])

(define_insn "min_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (umin:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(umin:SI (match_dup 1)
		 (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(umin:SI (match_dup 1)
		 (match_dup 2)))]
  ""
  "@
   min  %r1 %r2 %r0
   mini %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "min,mini")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "min_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(umin:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(umin:SI (match_dup 1)
		 (match_dup 2)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   min  %r1 %r2 %r0
   mini %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "min,mini")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "min_modx"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (umin:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (umin:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))]
  ""
  "min  %r1 %r2 %r0 %X3"
  [(set_attr "type" "arith")
   (set_attr "instruction" "min")
   (set_attr "octave_class" "alu3opabcmod")])

(define_insn "min_modx_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (umin:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "min  %r1 %r2 %r0 %X3"
  [(set_attr "type" "arith")
   (set_attr "instruction" "min")
   (set_attr "octave_class" "alu3opabcmod")])

(define_insn "min_modx_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (umin:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (umin:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (umin:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))]
  ""
  "min  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "min")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])

(define_insn "min_modx_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (umin:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (umin:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "min  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "min")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])

;
;  MUL: Multiply Registers
;
 
(define_insn "mul_unsigned"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(truncate:SI
	 (mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "%rZ,rZ"))
		  (zero_extend:DI (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T"))))
	)]
  ""
  "@
   mul %r1 %r2 %r0
   muli %r1 %2 %r0"
  [(set_attr "type" "mul,muli")
   (set_attr "instruction" "mul,muli")
   (set_attr "octave_class" "alu3opsx,alu3opsx")])
		  
   
(define_insn "mul_signed"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (mult:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
                 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))]
  ""
  "@
   mul %r1 %r2 %r0 SX
   muli %r1 %2 %r0 SX"
  [(set_attr "type" "mul,muli")
   (set_attr "instruction" "mul,muli")
   (set_attr "octave_class" "alu3opsx,alu3opsx")])

(define_insn "mulh_unsigned"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (truncate:SI 
         (lshiftrt:DI 
          (mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "%rZ,rZ"))
                   (zero_extend:DI (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))
          (const_int 32)))
	)]
  ""
  "@
   mulh %r1 %r2 %r0
   mulhi %r1 %2 %r0"
  [(set_attr "type" "mulh,mulhi")
   (set_attr "instruction" "mulh,mulhi")
   (set_attr "octave_class" "alu3opsx,alu3opsx")])


(define_insn "mulh_signed"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (truncate:SI 
         (lshiftrt:DI 
          (mult:DI (sign_extend:DI (match_operand:SI 1 "register_operand" "%rZ,rZ"))
                   (sign_extend:DI (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))
          (const_int 32)))
	)]
  ""
  "@
   mulh %r1 %r2 %r0 SX
   mulhi %r1 %2 %r0 SX"
  [(set_attr "type" "mulh,mulhi")
   (set_attr "instruction" "mulh,mulhi")
   (set_attr "octave_class" "alu3opsx,alu3opsx")])


;
;
; MV: Move Value
;
;

(define_expand "mv"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
        (match_operand:SI 1 "register_operand" "rZ"))]
  ""
  "
{
  /* Convert a 'mv rsa rd' to 'ori rsa 0 rd' */

  rtx constant0 = gen_rtx_CONST_INT(SImode, 0);
  emit_insn(gen_or(operands[0], operands[1],  constant0));
  DONE;
}")

(define_expand "mv_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
        (match_operand:SI 1 "register_operand" "rZ"))]
  ""
  "
{
  /* Convert a 'mv rsa rd' to 'ori rsa 0 rd' */

  rtx constant0 = gen_rtx_CONST_INT(SImode, 0);
  emit_insn(gen_or_clobber(operands[0], operands[1],  constant0));
  DONE;
}")


(define_expand "mv_lnk"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
        (match_operand:SI 1 "register_operand" "rZ"))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(match_dup 1))]
  ""
  "
{
  /* Convert a 'mv rsa rd' to 'ori rsa 0 rd' */

  rtx constant0 = gen_rtx_CONST_INT(SImode, 0);
  emit_insn(gen_or_lnk(operands[0], operands[1],  constant0, operands[2]));
  DONE;
}")


(define_expand "mv_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
        (match_operand:SI 1 "register_operand" "rZ"))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(match_dup 1))]
  ""
  "
{
  /* Convert a 'mv rsa rd' to 'ori rsa 0 rd' */

  rtx constant0 = gen_rtx_CONST_INT(SImode, 0);
  emit_insn(gen_or_lnk_clobber(operands[0], operands[1],  constant0, operands[2]));
  DONE;
}")


;
; MVHR: Move Hardware Register to Register
;

(define_insn "mvhr_lnk"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
        (unspec:SI [(match_operand:SI 1 "hardware_register_operand" "e")] U_MVHR))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(unspec:SI [(match_dup 1)] U_MVHR))]
  ""
  "mvhr %1 %0"
  [(set_attr "type" "mvhr")
   (set_attr "instruction" "mvhr")
   (set_attr "octave_class" "mvhop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])

(define_insn "mvhr_with_cn"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
        (unspec:SI [(match_operand:SI 1 "hardware_register_operand" "e")] U_MVHR))
   (use (match_operand 2 "const_int_operand" ""))]
  ""
  "mvhr %1 %0 c%2"
  [(set_attr "type" "mvhr")
   (set_attr "instruction" "mvhr")
   (set_attr "octave_class" "mvhop")])

(define_insn "mvhr_lnk_with_cn"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
        (unspec:SI [(match_operand:SI 1 "hardware_register_operand" "e")] U_MVHR))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(unspec:SI [(match_dup 1)] U_MVHR))
   (use (match_operand 3 "const_int_operand" ""))]
  ""
  "mvhr %1 %0 c%4"
  [(set_attr "type" "mvhr")
   (set_attr "instruction" "mvhr")
   (set_attr "octave_class" "mvhop")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])

;
;
; MVRH: Move Register to Hardware Register
;
;

(define_insn "mvrh_to_octcfg"
  [(unspec:SI [(set (reg:SI REG_64)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTCFG)]
  ""
  "mvrh  %0 r64"
  [(set_attr "type" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "instruction" "mvrh")
   (set_attr "mvrh_dest_reg" "r64")])

(define_insn "mvrh_to_octtrap"
  [(unspec:SI [(set (reg:SI REG_67)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTTRAP)]
  ""
  "mvrh  %0 r67"
  [(set_attr "type" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "instruction" "mvrh")
   (set_attr "mvrh_dest_reg" "r67")])

(define_insn "mvrh_to_octtrapen"
  [(unspec:SI [(set (reg:SI REG_68)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTTRAPEN)]
  ""
  "mvrh  %0 r68"
  [(set_attr "type" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "instruction" "mvrh")
   (set_attr "mvrh_dest_reg" "r68")])

(define_insn "mvrh_to_octglbitag"
  [(unspec:SI [(set (reg:SI REG_73)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTGLBITAG)]
  ""
  "mvrh  %0 r73"
  [(set_attr "type" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "instruction" "mvrh")
   (set_attr "mvrh_dest_reg" "r73")])

(define_insn "mvrh_to_octctl"
  [(unspec:SI [(set (reg:SI REG_74)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTCTL)]
  ""
  "mvrh  %0 r74"
  [(set_attr "type" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "instruction" "mvrh")
   (set_attr "mvrh_dest_reg" "r74")])

(define_insn "mvrh_to_octrtcctl"
  [(unspec:SI [(set (reg:SI REG_77)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTRTCCTL)]
  ""
  "mvrh  %0 r77"
  [(set_attr "type" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "instruction" "mvrh")
   (set_attr "mvrh_dest_reg" "r77")])

(define_insn "mvrh_to_bme_cfg"
  [(set (reg:SI REG_80)
	(match_operand:SI 0 "register_operand" "r"))
   (set (reg:CC REG_ESS_BMEHWEPD)
	(unspec:CC [(match_dup 0)] U_BME_HWEPD))
   (set (reg:CC REG_ESS_BMEEXHAUST)
	(unspec:CC [(match_dup 0)] U_BME_CFG))]
  ""
  "mvrh  %0 r80"
  [(set_attr "type" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "instruction" "mvrh")
   (set_attr "bme_dest_reg" "bmecfg")
   (set_attr "mvrh_dest_reg" "r80")])

(define_insn "mvrh_to_bmenextbuf"
  [(unspec:SI [(set (reg:SI REG_81)
		    (match_operand:SI 0 "register_operand" "r"))] U_GETBME_BUF)]
  ""
  "mvrh  %0 r81"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r81")])



(define_insn "mvrh_to_octtrappc"
  [(unspec:SI [(set (reg:SI REG_85)
		    (match_operand:SI 0 "register_operand" "r"))] U_SAVE_TRAP_PC)]
  ""
  "mvrh  %0 r85"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r85")])

(define_insn "mvrh_to_octoam_atmheader"
  [(unspec:SI [(set (reg:SI REG_93)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTOAM_ATMHDR)]
  ""
  "mvrh  %0 r93"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r93")])

(define_insn "mvrh_to_octoam_atmpayload"
  [(set (reg:SI REG_93)
	(unspec:SI [(reg:SI REG_93)
		    (match_operand:SI 0 "register_operand" "r")] U_OCTOAM_ATMPAYLOAD))]
  ""
  "mvrh  %0 r93"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r93")])

(define_insn "mvrh_to_software_epd"
  [(set (reg:SI REG_94)
	(match_operand:SI 0 "register_operand" "r"))
   (set (reg:CC REG_ESS_BMESWEPD)
	(unspec:CC [(match_dup 0)] U_BME_SWEPD))]
  ""
  "mvrh  %0 r94"
  [(set_attr "type" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "instruction" "mvrh")
   (set_attr "bme_dest_reg" "swepd")
   (set_attr "mvrh_dest_reg" "r94")])

(define_insn "mvrh_to_octdiag"
  [(unspec:SI [(set (reg:SI REG_95)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTDIAG)]
  ""
  "mvrh  %0 r95"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r95")])

(define_insn "mvrh_to_octlptr0"
  [(unspec:SI [(set (reg:SI REG_96)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTLPTR0)]
  ""
  "mvrh  %0 r96"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r96")])

(define_insn "mvrh_to_octlptr16"
  [(unspec:SI [(set (reg:SI REG_97)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTLPTR16)]
  ""
  "mvrh  %0 r97"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r97")])

(define_insn "mvrh_to_octlptr32"
  [(unspec:SI [(set (reg:SI REG_98)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTLPTR32)]
  ""
  "mvrh  %0 r98"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r98")])

(define_insn "mvrh_to_octlptr48"
  [(unspec:SI [(set (reg:SI REG_99)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTLPTR48)]
  ""
  "mvrh  %0 r99"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r99")])

(define_insn "mvrh_to_octlbase1"
  [(unspec:SI [(set (reg:SI REG_100)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTLBASE1)]
  ""
  "mvrh  %0 r100"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r100")])

(define_insn "mvrh_to_octlbase2"
  [(unspec:SI [(set (reg:SI REG_BASE2)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTLBASE2)]
  ""
  "mvrh  %0 r101"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r101")])

(define_insn "mvrh_to_octlbase3"
  [(unspec:SI [(set (reg:SI REG_BASE3)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTLBASE3)]
  ""
  "mvrh  %0 r102"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r102")])

(define_insn "mvrh_to_activeid"
  [(unspec:SI [(set (reg:SI REG_107)
		    (match_operand:SI 0 "register_operand" "r"))] U_ACTIVEID)]
  ""
  "mvrh  %0 r107"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r107")])

(define_insn "mvrh_to_activeid2"
  [(unspec:SI [(set (reg:SI REG_108)
		    (match_operand:SI 0 "register_operand" "r"))] U_ACTIVEID2)]
  ""
  "mvrh  %0 r108"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r108")])

(define_insn "mvrh_to_activeid3"
  [(unspec:SI [(set (reg:SI REG_109)
		    (match_operand:SI 0 "register_operand" "r"))] U_ACTIVEID3)]
  ""
  "mvrh  %0 r109"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r109")])

(define_insn "mvrh_to_activecid"
  [(unspec:SI [(set (reg:SI REG_110)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTACTIVECID)]
  ""
  "mvrh  %0 r110"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r110")])

(define_insn "mvrh_to_activecidxor"
  [(unspec:SI [(set (reg:SI REG_111)
		    (match_operand:SI 0 "register_operand" "r"))] U_OCTACTIVECIDXOR)]
  ""
  "mvrh  %0 r111"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")
   (set_attr "mvrh_dest_reg" "r111")])

(define_expand "mvrh"
  [(set (match_operand:SI 0 "hardware_register_operand" "")
	(match_operand:SI 1 "register_operand" ""))]
  ""
  "
{

  if (REG_P (operands[0]))
    {
      emit_mvrh_insn (operands[0], operands[1]);
      DONE;
    }
}")


(define_insn "mvrh_with_cn"
  [(set (match_operand:SI 0 "hardware_register_operand" "=e")
        (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_MVRH))
   (use (match_operand 2 "const_int_operand" ""))]
  ""
  "mvrh %1 %0 c%2"
  [(set_attr "type" "mvrh")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvhop")])

;
; NOP: No Operation
; 

(define_insn "nop"
  [(unspec_volatile [(const_int 0)] U_NOP)]
  ""
  "nop"
  [(set_attr "type" "nop")])

;
; OR Or Registers
;
; or rsa rsb rd [MODX] [ABC]
; ori rsa simm rd [MODX] [ABC]
;

(define_insn "or"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
		 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ior:SI (match_dup 1)
		(match_dup 2)))]
  ""
  "@
  or  %r1 %r2 %r0
  ori %r1 %2 %r0"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "or,ori")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")])

(define_insn "or_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (ior:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
		 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
  or  %r1 %r2 %r0
  ori %r1 %2 %r0"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "or,ori")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")])

(define_insn "or_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
		 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ior:SI (match_dup 1)
		(match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(ior:SI (match_dup 1)
		(match_dup 2)))]
  ""
  "@
  or  %r1 %r2 %r0
  ori %r1 %2 %r0"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "or,ori")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "or_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (ior:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
		 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(ior:SI (match_dup 1)
		(match_dup 2)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
  or  %r1 %r2 %r0
  ori %r1 %2 %r0"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "or,ori")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "or_modx"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (ior:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_dup 1) 
		 (not:SI (match_dup 3)))
	 (ior:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2) 
		  (match_dup 3)))))]
  ""
  "or  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "or")
   (set_attr "octave_class" "alu3opabcmod")])

(define_insn "or_modx_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (ior:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "or  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "or")
   (set_attr "octave_class" "alu3opabcmod")])

(define_insn "or_modx_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (ior:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_dup 1) 
		 (not:SI (match_dup 3)))
	 (ior:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2) 
		  (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 1) (not:SI (match_dup 3)))
	 (ior:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2) (match_dup 3)))))]
  ""
  "or  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "or")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])

(define_insn "or_modx_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (ior:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 1) (not:SI (match_dup 3)))
	 (ior:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2) (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "or  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "or")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])


;
;   PAR: Parity
;

(define_insn "par"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_PAR)
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(match_dup 1)] U_PAR))]
  ""
  "par %r0 %r1"
  [(set_attr "type" "arith")
   (set_attr "instruction" "par")
   (set_attr "octave_class" "alu2op")])

(define_insn "par_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_PAR))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "par %r0 %r1"
  [(set_attr "type" "arith")
   (set_attr "instruction" "par")
   (set_attr "octave_class" "alu2op")])

(define_insn "par_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_PAR)
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(match_dup 1)] U_PAR))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(unspec:SI [(match_dup 1)] U_PAR))]
  ""
  "par %r0 %r1"
  [(set_attr "type" "arith")
   (set_attr "instruction" "par")
   (set_attr "octave_class" "alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])

(define_insn "par_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ")] U_PAR))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(unspec:SI [(match_dup 1)] U_PAR))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "par %r0 %r1"
  [(set_attr "type" "arith")
   (set_attr "instruction" "par")
   (set_attr "octave_class" "alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true")])




;
; PUTC: Put Connection Into Scoreboard
;   
; putc rsa rsb FP FR GR GU GW GZ NB NC R I
;

(define_insn "putc_v3"
  [ (unspec:SI [(match_operand:SI 0  "register_operand" "rZ")
			 (match_operand:SI 1  "register_operand" "rZ") 
			 (match_operand:SI 2  "putc_flag_operand" "")
			 (match_operand:SI 3  "putc_flag_operand" "")
			 (match_operand:SI 4  "putc_flag_operand" "")
			 (match_operand:SI 5  "putc_flag_operand" "")
			 (match_operand:SI 6  "putc_flag_operand" "")
			 (match_operand:SI 7  "putc_flag_operand" "")
			 (match_operand:SI 8  "putc_flag_operand" "")
			 (match_operand:SI 9  "putc_flag_operand" "")
			 (match_operand:SI 10 "putc_flag_operand" "")
			 (match_operand:SI 11 "putc_flag_operand" "")] U_PUTC) 
    (use (reg:SI REG_110))
    (clobber (mem:BLK (match_scratch 12 "X")))]
  ""
  "putc %0 %1 %F2 %F3 %F4 %F5 %F6 %F7 %F8 %F9 %F10 %F11"
  [(set_attr "type" "put")
   (set_attr "instruction" "putc")
   (set_attr "octave_class" "tssrcop")])

(define_insn "putc_v4"
  [ (unspec:SI [(match_operand:SI 0  "register_operand" "rZ")
			 (match_operand:SI 1  "register_operand" "rZ") 
			 (match_operand:SI 2  "putc_flag_operand" "")
			 (match_operand:SI 3  "putc_flag_operand" "")
			 (match_operand:SI 4  "putc_flag_operand" "")
			 (match_operand:SI 5  "putc_flag_operand" "")
			 (match_operand:SI 6  "putc_flag_operand" "")
			 (match_operand:SI 7  "putc_flag_operand" "")
			 (match_operand:SI 8  "putc_flag_operand" "")
			 (match_operand:SI 9  "putc_flag_operand" "")
			 (match_operand:SI 10 "putc_flag_operand" "")
			 (match_operand:SI 11 "putc_flag_operand" "")
			 (match_operand:SI 12 "putc_flag_operand" "")] U_PUTC) 
    (use (reg:SI REG_110))
    (clobber (mem:BLK (match_scratch 13 "X")))]
  ""
  "putc %0 %1 %F2 %F3 %F4 %F5 %F6 %F7 %F8 %F9 %F10 %F11 %F12"
  [(set_attr "type" "put")
   (set_attr "instruction" "putc")
   (set_attr "octave_class" "tssrcop")])

;
; PUTM
;
; putm rsa rsb FP FR GR GU GW GZ NB NC R I
;

(define_insn "putm"
  [ (unspec:SI [(match_operand:SI 0  "register_operand" "rZ")
			 (match_operand:SI 1  "register_operand" "rZ") 
			 (match_operand:SI 2  "putm_flag_operand" "")
			 (match_operand:SI 3  "putm_flag_operand" "")
			 (match_operand:SI 4  "putm_flag_operand" "")
			 (match_operand:SI 5  "putm_flag_operand" "")
			 (match_operand:SI 6  "putm_flag_operand" "")
			 (match_operand:SI 7  "putm_flag_operand" "")
			 (match_operand:SI 8  "putm_flag_operand" "")
			 (match_operand:SI 9  "putm_flag_operand" "")
			 (match_operand:SI 10 "putm_flag_operand" "")
			 (match_operand:SI 11 "putm_flag_operand" "")] U_PUTM)
    (clobber (mem:BLK (match_scratch 12 "X")))]
  ""
  "putm %0 %1 %F2 %F3 %F4 %F5 %F6 %F7 %F8 %F9 %F10 %F11"
  [(set_attr "type" "put")
   (set_attr "instruction" "putm")
   (set_attr "octave_class" "tssrcop")])

(define_insn "putp"
  [ (unspec:SI [(match_operand:SI 0  "register_operand" "rZ")
			 (match_operand:SI 1  "register_operand" "rZ") 
			 (match_operand:SI 2  "putp_flag_operand" "")
			 (match_operand:SI 3  "putp_flag_operand" "")
			 (match_operand:SI 4  "putp_flag_operand" "")
			 (match_operand:SI 5  "putp_flag_operand" "")
			 (match_operand:SI 6  "putp_flag_operand" "")
			 (match_operand:SI 7  "putp_flag_operand" "")
			 (match_operand:SI 8  "putp_flag_operand" "")
			 (match_operand:SI 9  "putp_flag_operand" "")
			 (match_operand:SI 10 "putp_flag_operand" "")
			 (match_operand:SI 11 "putp_flag_operand" "")
			 (match_operand:SI 12 "putp_flag_operand" "")] U_PUTP)
    (use (reg:SI REG_110))
    (clobber (mem:BLK (match_scratch 13 "X")))]
  ""
  "putp %0 %1 %F2 %F3 %F4 %F5 %F6 %F7 %F8 %F9 %F10 %F11 %F12"
  [(set_attr "type" "put")
   (set_attr "instruction" "putp")
   (set_attr "octave_class" "tssrcop")])


;
;   RAND/RANDI: Randomize, Mask and Subtract
;

(define_insn "rand"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ,rZ")
		     (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M")] U_RAND)
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(unspec:SI [(match_dup 1) 
		    (match_dup 2)] U_RAND))
   (use (reg:SI REG_105))
   (use (reg:SI REG_106))]
  ""
  "@
   rand  %r1 %r2 %r0
   randi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "rand,randi")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])


(define_insn "rand_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ,rZ")
		     (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M")] U_RAND))
   (clobber (reg:CC REG_ESS))
   (use (reg:SI REG_105))
   (use (reg:SI REG_106))]
  ""
  "@
   rand  %r1 %r2 %r0
   randi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "rand,randi")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])


(define_insn "rand_lnk"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ,rZ")
		     (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M")] U_RAND)
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(unspec:SI [(match_dup 1) 
		    (match_dup 2)] U_RAND))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(unspec:SI [(match_dup 1) 
		    (match_dup 2)] U_RAND))
   (use (reg:SI REG_105))
   (use (reg:SI REG_106))]
  ""
  "@
   rand  %r1 %r2 %r0
   randi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "rand,randi")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "rand_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (unspec:SI [(match_operand:SI 1 "register_operand" "rZ,rZ")
		     (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M")] U_RAND))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(unspec:SI [(match_dup 1) 
		    (match_dup 2)] U_RAND))
   (clobber (reg:CC REG_ESS))
   (use (reg:SI REG_105))
   (use (reg:SI REG_106))]
  ""
  "@
   rand  %r1 %r2 %r0
   randi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "rand,randi")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])


;
;   RINT: Return From Interrupt Handler
;

(define_insn "rint_di"
  [(set (pc) (match_operand 0 "immediate_operand" ""))
   (use (reg:SI REG_87))
   (use (const_int FLAG_DI))]
  ""
  "rint DI %*"
  [(set_attr "type" "branch")
   (set_attr "instruction" "rint")
   (set_attr "octave_class" "returnop")])



;
;   RNMI: Return from NMI Handler
;

(define_insn "rnmi_di"
  [(set (pc) (match_operand 0 "immediate_operand" ""))
   (use (reg:SI REG_88))
   (use (const_int FLAG_DI))]
  ""
  "rnmi DI"
  [(set_attr "type" "branch")
   (set_attr "instruction" "rnmi")
   (set_attr "octave_class" "returnop")])


;
; ROTL/ROTLI: Rotate Left 
;

(define_insn "rotl"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (rotate:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(rotate:SI (match_dup 1) 
		   (match_dup 2)))]
  ""
  "@
   rotl  %r1 %r2 %r0
   rotli %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "rotl,rotli")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])

(define_insn "rotl_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (rotate:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   rotl  %r1 %r2 %r0
   rotli %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "rotl,rotli")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])


(define_insn "rotl_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (rotate:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(rotate:SI (match_dup 1) 
		   (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(rotate:SI (match_dup 1) 
		   (match_dup 2)))]
  ""
  "@
   rotl  %r1 %r2 %r0
   rotli %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "rotl,rotli")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "rotl_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(rotate:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(rotate:SI (match_dup 1) 
		   (match_dup 2)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   rotl  %r1 %r2 %r0
   rotli %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "rotl,rotli")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])


;
; ROTR/ROTRI: Rotate Right
;


(define_insn "rotr"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (rotatert:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		      (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(rotatert:SI (match_dup 1) 
		     (match_dup 2)))]
  ""
  "@
   rotr  %r1 %r2 %r0
   rotri %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "rotr,rotri")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])


(define_insn "rotr_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (rotatert:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		      (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   rotr  %r1 %r2 %r0
   rotri %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "rotr,rotri")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])

(define_insn "rotr_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (rotatert:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		      (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(rotatert:SI (match_dup 1) 
		     (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(rotatert:SI (match_dup 1) 
		     (match_dup 2)))]
  ""
  "@
   rotr  %r1 %r2 %r0
   rotri %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "rotr,rotri")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "rotr_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (rotatert:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		      (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(rotatert:SI (match_dup 1) 
		     (match_dup 2)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   rotr  %r1 %r2 %r0
   rotri %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "rotr,rotri")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])



;
; SETB: Set Bit
;

(define_insn "setb"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		 (ashift:SI (const_int 1) 
			    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ior:SI (match_dup 1)
		(ashift:SI (const_int 1) 
			   (match_dup 2))))]
  ""
  "@
   setb  %r0 %r1 %r2
   setbi %r0 %1 %r2"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "setb,setbi")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])

(define_insn "setb_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (ior:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		 (ashift:SI (const_int 1) 
			    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   setb  %r0 %r1 %r2
   setbi %r0 %1 %r2"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "setb,setbi")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])


(define_insn "setb_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		 (ashift:SI (const_int 1) 
			    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))
	 (const_int 0)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(ior:SI (match_dup 1)
		(ashift:SI (const_int 1) 
			   (match_dup 2))))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ior:SI (match_dup 1)
		(ashift:SI (const_int 1) 
			   (match_dup 2))))]
  ""
  "@
   setb  %r0 %r1 %r2
   setbi %r0 %1 %r2"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "setb,setbi")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])



(define_insn "setb_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ior:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		 (ashift:SI (const_int 1) 
			    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(ior:SI (match_dup 1)
		(ashift:SI (const_int 1) 
			   (match_dup 2))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   setb  %r0 %r1 %r2
   setbi %r0 %1 %r2"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "setb,setbi")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])


;
; SHFT/SHFTA: Shift Signed Amount
;

(define_insn "shft"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (match_operand:SI 1 "register_operand" "rZ")
	 (match_operand:SI 2 "register_operand" "rZ")))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(if_then_else:SI 
	 (gt:SI (ashiftrt:SI 
		 (ashift:SI  (match_dup 1) (const_int 24)) 
		 (const_int 24))
		(const_int 0))
	 (ashift:SI (match_dup 2) (match_dup 1))
	 (lshiftrt:SI (match_dup 2) (match_dup 1))))]
  ""
  "shft %r2 %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "shft")
   (set_attr "octave_class" "alu3opabc")])

(define_insn "shft_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(if_then_else:SI 
	 (gt:SI (ashiftrt:SI 
		 (ashift:SI  (match_operand:SI 1 "register_operand" "rZ") (const_int 24)) 
		 (const_int 24))
		(const_int 0))
	 (ashift:SI (match_operand:SI 2 "register_operand" "rZ") (match_dup 1))
	 (lshiftrt:SI (match_dup 2) (match_dup 1))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "shft %r2 %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "shft")
   (set_attr "octave_class" "alu3opabc")])

(define_insn "shft_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (match_operand:SI 1 "register_operand" "rZ")
	 (match_operand:SI 2 "register_operand" "rZ")))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(if_then_else:SI 
	 (gt:SI (ashiftrt:SI 
		 (ashift:SI  (match_dup 1) (const_int 24)) 
		 (const_int 24))
		(const_int 0))
	 (ashift:SI (match_dup 2) (match_dup 1))
	 (lshiftrt:SI (match_dup 2) (match_dup 1))))
   (set (match_operand:SI 3 "memory_operand" "=S")
	(if_then_else:SI 
	 (gt:SI (ashiftrt:SI 
		 (ashift:SI (match_dup 1) (const_int 24)) 
		 (const_int 24))
		(const_int 0))
	 (ashift:SI (match_dup 2) (match_dup 1))
	 (lshiftrt:SI (match_dup 2) (match_dup 1))))]
  ""
  "shft %r2 %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "shft")
   (set_attr "octave_class" "alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true")])

(define_insn "shft_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(if_then_else:SI 
	 (gt:SI (ashiftrt:SI 
		 (ashift:SI  (match_operand:SI 1 "register_operand" "rZ") (const_int 24)) 
		 (const_int 24))
		(const_int 0))
	 (ashift:SI (match_operand:SI 2 "register_operand" "rZ") (match_dup 1))
	 (lshiftrt:SI (match_dup 2) (match_dup 1))))
   (set (match_operand:SI 3 "memory_operand" "=S")
	(if_then_else:SI 
	 (gt:SI (ashiftrt:SI 
		 (ashift:SI (match_dup 1) (const_int 24)) 
		 (const_int 24))
		(const_int 0))
	 (ashift:SI (match_dup 2) (match_dup 1))
	 (lshiftrt:SI (match_dup 2) (match_dup 1))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "shft %r2 %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "shft")
   (set_attr "octave_class" "alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true")])


;
;
; SHFTA
;
;


(define_insn "shfta"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(if_then_else:SI 
	 (gt:SI (ashiftrt:SI 
		 (ashift:SI  (match_operand:SI 1 "register_operand" "rZ") (const_int 24)) 
		 (const_int 24))
		(const_int 0))
	 (ashift:SI (match_operand:SI 2 "register_operand" "rZ") (match_dup 1))
	 (ashiftrt:SI (match_dup 2) (match_dup 1))))   
   (set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (match_dup 1)
	 (match_dup 2)))]
  ""
  "shfta %r2 %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "shfta")
   (set_attr "octave_class" "alu3opabc")])

(define_insn "shfta_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(if_then_else:SI 
	 (gt:SI (ashiftrt:SI 
		 (ashift:SI  (match_operand:SI 1 "register_operand" "rZ") (const_int 24)) 
		 (const_int 24))
		(const_int 0))
	 (ashift:SI (match_operand:SI 2 "register_operand" "rZ") (match_dup 1))
	 (ashiftrt:SI (match_dup 2) (match_dup 1))))   
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "shfta %r2 %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "shfta")
   (set_attr "octave_class" "alu3opabc")])

   
(define_insn "shfta_lnk"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(if_then_else:SI 
	 (gt:SI (ashiftrt:SI 
		 (ashift:SI  (match_operand:SI 1 "register_operand" "rZ") (const_int 24)) 
		 (const_int 24))
		(const_int 0))
	 (ashift:SI (match_operand:SI 2 "register_operand" "rZ") (match_dup 1))
	 (ashiftrt:SI (match_dup 2) (match_dup 1))))
   (set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (match_dup 1)
	 (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S")
	(if_then_else:SI 
	 (gt:SI (ashiftrt:SI 
		 (ashift:SI (match_dup 1) (const_int 24)) 
		 (const_int 24))
		(const_int 0))
	 (ashift:SI (match_dup 2) (match_dup 1))
	 (ashiftrt:SI (match_dup 2) (match_dup 1))))]
  ""
  "shfta %r2 %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "shfta")
   (set_attr "octave_class" "alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true")])

   
(define_insn "shfta_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(if_then_else:SI 
	 (gt:SI (ashiftrt:SI 
		 (ashift:SI  (match_operand:SI 1 "register_operand" "rZ") (const_int 24)) 
		 (const_int 24))
		(const_int 0))
	 (ashift:SI (match_operand:SI 2 "register_operand" "rZ") (match_dup 1))
	 (ashiftrt:SI (match_dup 2) (match_dup 1))))
   (set (match_operand:SI 3 "memory_operand" "=S")
	(if_then_else:SI 
	 (gt:SI (ashiftrt:SI 
		 (ashift:SI (match_dup 1) (const_int 24)) 
		 (const_int 24))
		(const_int 0))
	 (ashift:SI (match_dup 2) (match_dup 1))
	 (ashiftrt:SI (match_dup 2) (match_dup 1))))
      (clobber (reg:CCUNS REG_ESS))]
  ""
  "shfta %r2 %r1 %r0"
  [(set_attr "type" "logical")
   (set_attr "instruction" "shfta")
   (set_attr "octave_class" "alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true")])

; 
; SHL/SHLI: Shift Left
;

(define_insn "shl"
  [(set (reg:CCUNS REG_ESS)
        (compare:CCUNS
         (ashift:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
                    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))
         (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
        (ashift:SI (match_dup 1)
                   (match_dup 2)))]
  ""
  "@
   shl  %r1 %r2 %r0
   shli %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "shl,shli")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])


(define_insn "shl_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (ashift:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   shl  %r1 %r2 %r0
   shli %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "shl,shli")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])


(define_insn "shl_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ashift:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		    (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ashift:SI (match_dup 1) (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(ashift:SI (match_dup 1) (match_dup 2)))]
  ""
  "@
   shl  %r1 %r2 %r0
   shli %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "shl,shli")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "shl_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ashift:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		   (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(ashift:SI (match_dup 1) (match_dup 2)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   shl  %r1 %r2 %r0
   shli %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "shl,shli")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])



;
; SHR/SHRI: Shift Right
;

(define_insn "shr"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (lshiftrt:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		      (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(lshiftrt:SI (match_dup 1) 
		     (match_dup 2)))]
  ""
  "@
   shr  %r1 %r2 %r0
   shri %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "shr,shri")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])

(define_insn "shr_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(lshiftrt:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		      (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   shr  %r1 %r2 %r0
   shri %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "shr,shri")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])



(define_insn "shr_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (lshiftrt:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		      (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(lshiftrt:SI (match_dup 1) 
		     (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(lshiftrt:SI (match_dup 1) 
		     (match_dup 2)))]
  ""
  "@
   shr  %r1 %r2 %r0
   shri %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "shr,shri")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "shr_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (lshiftrt:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		      (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(lshiftrt:SI (match_dup 1) 
		     (match_dup 2)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   shr  %r1 %r2 %r0
   shri %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "shr,shri")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])



;
; SHRA/SHRAI: Shift Right Arithmetic
;


(define_insn "shra"
  [(set (reg:CCUNS REG_ESS)	
	(compare:CCUNS
	 (ashiftrt:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		      (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ashiftrt:SI (match_dup 1) 
		     (match_dup 2)))]
  ""
  "@
   shra  %r1 %r2 %r0
   shrai %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "shra,shrai")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])


(define_insn "shra_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (ashiftrt:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		      (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   shra  %r1 %r2 %r0
   shrai %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "shra,shrai")
   (set_attr "octave_class" "alu3opabc,alu3opabc")])


(define_insn "shra_lnk"
  [(set (reg:CCUNS REG_ESS)	
	(compare:CCUNS
	 (ashiftrt:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		      (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ashiftrt:SI (match_dup 1) 
		     (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(ashiftrt:SI (match_dup 1) 
		     (match_dup 2)))]
  ""
  "@
   shra  %r1 %r2 %r0
   shrai %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "shra,shrai")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "shra_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (ashiftrt:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		      (match_operand:SI 2 "reg_or_5bu_operand" "rZ,L")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(ashiftrt:SI (match_dup 1) 
		     (match_dup 2)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   shra  %r1 %r2 %r0
   shrai %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "shra,shrai")
   (set_attr "octave_class" "alu3opabc,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])



;
;  SUB/SUBI Subtract Registers 
;    
;  sub rsa rsb rd [MODX] [ABC]
;  subi rsa usi6 rd [MODX] [ABC]
;

(define_insn "sub"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (minus:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		   (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(minus:SI (match_dup 1)
		  (match_dup 2)))]
  ""
  "@
   sub  %r1 %r2 %r0
   subi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "sub,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")])

(define_insn "sub_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (minus:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		   (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M")))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   sub  %r1 %r2 %r0
   subi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "sub,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")])

(define_insn "sub_lnk"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (minus:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		   (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(minus:SI (match_dup 1)
		  (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(minus:SI (match_dup 1)
		  (match_dup 2)))]
  ""
  "@
   sub  %r1 %r2 %r0
   subi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "sub,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "sub_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(minus:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		   (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(minus:SI (match_dup 1)
		  (match_dup 2)))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   sub  %r1 %r2 %r0
   subi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "sub,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "sub_modx"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (minus:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M")
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (minus:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))]
  ""
  "@
  sub  %r1 %r2 %r0 %X3
  subi %r1 %2 %r0 %X3"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "sub,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")])

(define_insn "sub_modx_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (minus:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M")
		   (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
  sub  %r1 %r2 %r0 %X3
  subi %r1 %2 %r0 %X3"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "sub,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")])

(define_insn "sub_modx_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (minus:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M")
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (minus:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S,S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (minus:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))]
  ""
  "@
  sub  %r1 %r2 %r0 %X3
  subi %r1 %2 %r0 %X3"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "sub,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "sub_modx_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (minus:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M")
		   (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S,S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (minus:SI
	  (and:SI (match_dup 1) 
		  (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
  sub  %r1 %r2 %r0 %X3
  subi %r1 %2 %r0 %X3"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "sub,subi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true")])

;
;  SUBB:  Sub Registers With Barrow
;  SUBBI: Sub Register w/ Immediate and Barrow 
; 
;  subb rsa rsb rd  [MODX] [ABC]
;  subb rsa usi6 rd [MODX] [ABC]
;

(define_insn "subb"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (minus:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		   (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(minus:SI (match_dup 1)
		  (match_dup 2)))
   (use (reg:CC REG_ESS))]
  ""
  "@
   subb  %r1 %r2 %r0
   subbi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subb,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")])

(define_insn "subb_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (minus:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		   (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M")))
   (use (reg:CC REG_ESS))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   subb  %r1 %r2 %r0
   subbi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subb,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")])

(define_insn "subb_lnk"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (minus:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		   (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(minus:SI (match_dup 1)
		  (match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(minus:SI (match_dup 1)
		  (match_dup 2)))
   (use (reg:CC REG_ESS))]
  ""
  "@
   subb  %r1 %r2 %r0
   subbi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subb,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "subb_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (minus:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		   (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(minus:SI (match_dup 1)
		  (match_dup 2)))
   (use (reg:CC REG_ESS))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   subb  %r1 %r2 %r0
   subbi %r1 %2 %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subb,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "subb_modx"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (minus:SI (and:SI (match_dup 1) (match_dup 3))
		    (and:SI (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M") 
			    (match_dup 3))))
	 (const_int 0)))
   (set  (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (ior:SI 
	  (and:SI (match_dup 1)
		  (not:SI (match_dup 3)))
	  (minus:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_dup 2)
		   (match_dup 3)))))
   (use (reg:CC REG_ESS))]
  ""
  "@
   subb  %r1 %r2 %r0 %X3
   subbi %r1 %2 %r0 %X3"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "subb,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")])

(define_insn "subb_modx_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (minus:SI (and:SI (match_dup 1) (match_dup 3))
		    (and:SI (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M") 
			    (match_dup 3)))))
   (use (reg:CC REG_ESS))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   subb  %r1 %r2 %r0 %X3
   subbi %r1 %2 %r0 %X3"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "subb,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")])

(define_insn "subb_modx_lnk"
  [(set (reg:CC REG_ESS)
	(compare:CC
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (minus:SI (and:SI (match_dup 1) (match_dup 3))
		    (and:SI (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M") 
			    (match_dup 3))))
	 (const_int 0)))
   (set  (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (ior:SI 
	  (and:SI (match_dup 1)
		  (not:SI (match_dup 3)))
	  (minus:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_dup 2)
		   (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S,S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (minus:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (use (reg:CC REG_ESS))]
  ""
  "@
   subb  %r1 %r2 %r0 %X3
   subbi %r1 %2 %r0 %X3"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "subb,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "subb_modx_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ,rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" "")))
	  (minus:SI (and:SI (match_dup 1) (match_dup 3))
		    (and:SI (match_operand:SI 2 "reg_or_6bu_operand" "rZ,M") 
			    (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S,S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (minus:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (use (reg:CC REG_ESS))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   subb  %r1 %r2 %r0 %X3
   subbi %r1 %2 %r0 %X3"
  [(set_attr "type" "logical,logical")
   (set_attr "instruction" "subb,subbi")
   (set_attr "octave_class" "alu3opabcmod,alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true,true")])



;
; SUBL/SUBLI  Add Long
; 
; subl rsb rd [br=disp]
; subl usi rd [br=disp]
;

(define_expand "subl"
  [(set (match_operand:SI 0 "register_operand" "")
        (minus:SI (match_dup 0)
		  (match_operand:SI 1 "reg_or_6bu_operand" "")))]
  ""
  "
{     /* Convert a 'subl' with no branch displacement into a regular 'sub' */
      emit_insn(gen_sub(operands[0], operands[0], operands[1]));
      DONE;
}")


(define_expand "subl_clobber"
  [(set (match_operand:SI 0 "register_operand" "")
        (minus:SI (match_dup 0)
		  (match_operand:SI 1 "reg_or_6bu_operand" "")))]
  ""
  "
{     /* Convert a 'subl' with no branch displacement into a regular 'sub' */
      emit_insn(gen_sub_clobber(operands[0], operands[0], operands[1]));
      DONE;
}")


(define_expand "subl_lnk"
  [(set (match_operand:SI 0 "register_operand" "")
        (minus:SI (match_dup 0)
		  (match_operand:SI 1 "reg_or_6bu_operand" "")))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(minus:SI (match_dup 0)
		  (match_dup 1)))]
  ""
  "
{     /* Convert a 'subl' with no branch displacement into a regular 'add' */
      emit_insn(gen_sub_lnk(operands[0], operands[1], operands[2], operands[3]));
      DONE;
}")


(define_expand "subl_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "")
        (minus:SI (match_dup 0)
		  (match_operand:SI 1 "reg_or_6bu_operand" "")))
   (set (match_operand:SI 2 "memory_operand" "=S")
	(minus:SI (match_dup 0)
		  (match_dup 1)))]
  ""
  "
{     /* Convert a 'subl' with no branch displacement into a regular 'add' */
      emit_insn(gen_sub_lnk_clobber(operands[0], operands[1], operands[2], operands[3]));
      DONE;
}")

;
; SUBL/SUBLI  Add Long
; 
; subl rsb rd [br=disp]
; subl usi rd [br=disp]
;

(define_insn "subl_br"
  [(set (pc)
	(if_then_else:SI (lt (minus:SI 
			      (match_operand:SI 0 "register_operand" "+rZ,rZ") 
			      (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M"))
			     (const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (minus:SI (match_dup 0)
		  (match_dup 1)))
   (set (reg:CC REG_ESS)
	(compare:CC
	 (minus:SI (match_dup 0)
		   (match_dup 1))
	 (const_int 0)))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subl\");
	   return \"subl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subli\");
	   return \"subli  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subl,subli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

(define_insn "subl_br_clobber"
  [(set (pc)
	(if_then_else:SI (lt (minus:SI 
			      (match_operand:SI 0 "register_operand" "+rZ,rZ") 
			      (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M"))
			     (const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (minus:SI (match_dup 0)
		  (match_dup 1)))
   (clobber (reg:CC REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subl\");
	   return \"subl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subli\");
	   return \"subli  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subl,subli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

(define_insn "subl_br_lnk"
  [(set (pc)
	(if_then_else:SI (lt (minus:SI 
			      (match_operand:SI 0 "register_operand" "+rZ,rZ") 
			      (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M"))
			     (const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (minus:SI (match_dup 0)
		  (match_dup 1)))
   (set (reg:CC REG_ESS)
	(compare:CC
	 (minus:SI (match_dup 0)
		   (match_dup 1))
	 (const_int 0)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(minus:SI (match_dup 0)
		  (match_dup 1)))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subl\");
	   return \"subl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subli\");
	   return \"subli  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
			       (const_int -256))
			   (lt (minus (match_dup 2) (pc))
			       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

(define_insn "subl_br_lnk_clobber"
  [(set (pc)
	(if_then_else:SI (lt (minus:SI 
			      (match_operand:SI 0 "register_operand" "+rZ,rZ") 
			      (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M"))
			     (const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (minus:SI (match_dup 0)
		  (match_dup 1)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(minus:SI (match_dup 0)
		  (match_dup 1)))
      (clobber (reg:CC REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subl\");
	   return \"subl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subli\");
	   return \"subli  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
			       (const_int -256))
			   (lt (minus (match_dup 2) (pc))
			       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])


;
;
; SUBWH/SUBWHI Add Word High
;  
; subwh rsb rsd [br=disp]
; subwhi usi rsd [br=disp]
;
;

(define_insn "subwh"
  [(set (reg:CC_NOOV  REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (and:SI 
		  (match_operand:SI 0 "register_operand" "+rZ,rZ")
		  (const_int 65535))
		 (ashift:SI (zero_extend:SI (minus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 0)))
			    (const_int 16)))
	 (const_int 0)))
   (set (match_dup 0)
	(ior:SI (and:SI 
		 (match_dup 0) 
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))]
  ""
  "@
   subwh  %r1 %r0
   subwhi  %1  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subwh,subwhi")
   (set_attr "octave_class" "alu2op,alu2op")])

(define_insn "subwh_clobber"
  [(set (match_operand:SI 0 "register_operand" "+rZ,rZ")
	 (ior:SI (and:SI 
		  (match_dup 0)	  
		  (const_int 65535))
		 (ashift:SI (zero_extend:SI (minus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 0)))
			    (const_int 16))))
   (clobber (reg:CC_NOOV  REG_ESS))]
  ""
  "@
   subwh  %r1 %r0
   subwhi  %1  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subwh,subwhi")
   (set_attr "octave_class" "alu2op,alu2op")])

(define_insn "subwh_lnk"
  [(set (reg:CC_NOOV  REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (and:SI 
		  (match_operand:SI 0 "register_operand" "+rZ,rZ")
		  (const_int 65535))
		 (ashift:SI (zero_extend:SI (minus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 0)))
			    (const_int 16)))
	 (const_int 0)))
   (set (match_dup 0)
	(ior:SI (and:SI 
		 (match_dup 0) 
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (match_operand:SI 2 "memory_operand" "=S,S")
	(ior:SI (and:SI 
		 (match_dup 0) 
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))]
  ""
  "@
   subwh  %r1 %r0
   subwhi %1  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subwh,subwhi")
   (set_attr "octave_class" "alu2op,alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "subwh_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "+rZ,rZ")
	 (ior:SI (and:SI 
		  (match_dup 0)
		  (const_int 65535))
		 (ashift:SI (zero_extend:SI (minus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 0)))
			    (const_int 16))))
   (set (match_operand:SI 2 "memory_operand" "=S,S")
	(ior:SI (and:SI 
		 (match_dup 0) 
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (clobber (reg:CC_NOOV  REG_ESS))]
  ""
  "@
   subwh  %r1 %r0
   subwhi %1  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subwh,subwhi")
   (set_attr "octave_class" "alu2op,alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true,true")])



;
;
; SUBWH/SUBWHI Add Word High
;  
; subwh rsb rsd [br=disp]
; subwhi usi rsd [br=disp]
;
;

(define_insn "subwh_br"
  [(set (pc)
	(if_then_else:SI (lt (minus:HI 
			      (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 0)
			      (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,rZ") 0))
			     (const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (and:SI 
		 (match_dup 0)
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (reg:CC_NOOV REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (and:SI 
		  (match_dup 0)
		  (const_int 65535))
		 (ashift:SI (zero_extend:SI (minus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16)))
	 (const_int 0)))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subwh  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwh\");
	   return \"subwh  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subwhi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwhi\");
	   return \"subwhi  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subwh,subwhi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])


(define_insn "subwh_br_clobber"
  [(set (pc)
	(if_then_else:SI (lt (minus:HI 
			      (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 0)
			      (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,rZ") 0))
			     (const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (and:SI 
		 (match_dup 0)
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (clobber (reg:CC_NOOV REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subwh  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwh\");
	   return \"subwh  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subwhi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwhi\");
	   return \"subwhi  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subwh,subwhi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])


(define_insn "subwh_br_lnk"
  [(set (pc)
	(if_then_else:SI (lt (minus:HI 
			      (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 0)
			      (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 0))
			     (const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (and:SI 
		 (match_dup 0)
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (reg:CC_NOOV REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (and:SI 
		  (match_dup 0)
		  (const_int 65535))
		 (ashift:SI (zero_extend:SI (minus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16)))
	 (const_int 0)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(ior:SI (and:SI 
		 (match_dup 0) 
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subwh  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwh\");
	   return \"subwh  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subwhi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwhi\");
	   return \"subwhi  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subwh,subwhi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

(define_insn "subwh_br_lnk_clobber"
  [(set (pc)
	(if_then_else:SI (lt (minus:HI 
			      (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 0)
			      (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 0))
			     (const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (and:SI 
		 (match_dup 0)
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(ior:SI (and:SI 
		 (match_dup 0) 
		 (const_int 65535))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (clobber (reg:CC_NOOV REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subwh  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwh\");
	   return \"subwh  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subwhi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwhi\");
	   return \"subwhi  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subwh,subwhi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])
;
;
; SUBWL/SUBWLI Add Word Low 
;
; subwl  rsb rsd [br=disp]
; subwli usi rsd [br=disp]
;
;

(define_insn "subwl"
  [(set (strict_low_part (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 2))
        (minus:HI (subreg:HI  (match_dup 0) 2)
		  (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 2)))
   (set (reg:CC_NOOV REG_ESS)
	(compare:CC_NOOV
	 (minus:HI (subreg:HI (match_dup 0) 2)
		   (subreg:HI (match_dup 1) 2))
	 (const_int 0)))]
  ""
  "@
   subwl   %r1 %r0
   subwli  %1  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subwl,subwli")
   (set_attr "octave_class" "alu2op,alu2op")])

(define_insn "subwl_clobber"
  [(set (strict_low_part (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 2))
        (minus:HI (subreg:HI  (match_dup 0) 2)
		  (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 2)))
   (clobber (reg:CC_NOOV REG_ESS))]
  ""
  "@
   subwl   %r1 %r0
   subwli  %1  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subwl,subwli")
   (set_attr "octave_class" "alu2op,alu2op")])

(define_insn "subwl_lnk"
  [(set (reg:CC_NOOV REG_ESS)
	(compare:CC_NOOV
	 (minus:HI (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 2)
		   (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 2))
	 (const_int 0)))
   (set (strict_low_part (subreg:HI (match_dup 0) 2))
	(minus:HI (subreg:HI (match_dup 0) 2)
		  (subreg:HI (match_dup 1) 2)))
   (set (match_operand:HI 2 "memory_operand" "=S,S")
        (minus:HI (subreg:HI (match_dup 0) 2)
		  (subreg:HI (match_dup 1) 2)))]
  ""
  "@
   subwl   %r1 %r0
   subwli  %1  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subwl,subwli")
   (set_attr "octave_class" "alu2op,alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "subwl_lnk_clobber"
  [(set (strict_low_part (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 2))
	 (minus:HI (subreg:HI (match_dup 0) 2)
		   (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 2)))
   (set (match_operand:HI 2 "memory_operand" "=S,S")
        (minus:HI (subreg:HI (match_dup 0) 2)
		  (subreg:HI (match_dup 1) 2)))
   (clobber (reg:CC_NOOV REG_ESS))]
  ""
  "@
   subwl   %r1 %r0
   subwli  %1  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subwl,subwli")
   (set_attr "octave_class" "alu2op,alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true,true")])


;
; SUBWL/SUBWLI Add Word Low 
;
; subwl  rsb rsd [br=disp]
; subwli usi rsd [br=disp]
;
;

(define_insn "subwl_br"
  [(set (pc)
	(if_then_else:SI (lt:HI (minus:HI 
				 (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 2)
				 (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 2))
				(const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (strict_low_part (subreg:HI (match_dup 0) 2))
        (minus:HI (subreg:HI (match_dup 0) 2)
		  (subreg:HI (match_dup 1) 2)))
   (set (reg:CC_NOOV REG_ESS)
	(compare:CC_NOOV
	 (minus:HI (subreg:HI (match_dup 0) 2)
		   (subreg:HI (match_dup 1) 2))
	 (const_int 0)))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subwl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwl\");
	   return \"subwl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subwli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwli\");
	   return \"subwli  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subwl,subwli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

(define_insn "subwl_br_clobber"
  [(set (pc)
	(if_then_else:SI (lt:HI (minus:HI 
				 (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 2)
				 (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 2))
				(const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (strict_low_part (subreg:HI (match_dup 0) 2))
        (minus:HI (subreg:HI (match_dup 0) 2)
		  (subreg:HI (match_dup 1) 2)))
   (clobber (reg:CC_NOOV REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subwl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwl\");
	   return \"subwl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subwli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwli\");
	   return \"subwli  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subwl,subwli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])


(define_insn "subwl_br_lnk"
  [(set (pc)
	(if_then_else:SI (lt:HI (minus:HI 
				 (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 2)
				 (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 2))
				(const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (strict_low_part (subreg:HI (match_dup 0) 2))
        (minus:HI (subreg:HI (match_dup 0) 2)
		  (subreg:HI (match_dup 1) 2)))
   (set (reg:CC_NOOV REG_ESS)
	(compare:CC_NOOV
	 (minus:HI (subreg:HI (match_dup 0) 2)
		   (subreg:HI (match_dup 1) 2))
	 (const_int 0)))
   (set (match_operand:HI 3 "memory_operand" "=S,S")
        (minus:HI (subreg:HI (match_dup 0) 2)
		  (subreg:HI (match_dup 1) 2)))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subwl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwl\");
	   return \"subwl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subwli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwli\");
	   return \"subwli  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subwl,subwli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])


(define_insn "subwl_br_lnk_clobber"
  [(set (pc)
	(if_then_else:SI (lt:HI (minus:HI 
				 (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 2)
				 (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 2))
				(const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (strict_low_part (subreg:HI (match_dup 0) 2))
        (minus:HI (subreg:HI (match_dup 0) 2)
		  (subreg:HI (match_dup 1) 2)))
   (set (match_operand:HI 3 "memory_operand" "=S,S")
        (minus:HI (subreg:HI (match_dup 0) 2)
		  (subreg:HI (match_dup 1) 2)))
   (clobber (reg:CC_NOOV REG_ESS))]

  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subwl  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwl\");
	   return \"subwl  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subwli  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwli\");
	   return \"subwli  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subwl,subwli")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])



;
;
; SUBWW/SUBWWI Add Two Words 
;
; subww rsb rd [br=disp]
; subwwi usi rd [br=disp]
;
;


(define_insn "subww"
  [(set (reg:CC_NOOV  REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 2) 
					   (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 2)))
		 (ashift:SI (zero_extend:SI (minus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16)))
	 (const_int 0)))
   (set (match_dup 0)
	(ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))]
  ""
  "@
   subww  %r1 %r0
   subwwi %1  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subww,subwwi")
   (set_attr "octave_class" "alu2op,alu2op")])


(define_insn "subww_clobber"
  [(set (match_operand:SI 0 "register_operand" "+rZ,rZ")
	 (ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					   (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 2)))
		 (ashift:SI (zero_extend:SI (minus:HI 
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16))))
   (clobber (reg:CC_NOOV  REG_ESS))]
  ""
  "@
   subww  %r1 %r0
   subwwi %1  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subww,subwwi")
   (set_attr "octave_class" "alu2op,alu2op")])

(define_insn "subww_lnk"
  [(set (reg:CC_NOOV  REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 2) 
					   (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 2)))
		 (ashift:SI (minus:HI 
			     (subreg:HI (match_dup 0) 0)
			     (subreg:HI (match_dup 1) 0))
			    (const_int 16)))
	 (const_int 0)))
   (set (match_dup 0)
	(ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (match_operand:SI 2 "memory_operand" "=S,S")
        (ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))]
  ""
  "@
   subww  %r1 %r0
   subwwi %1  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subww,subwwi")
   (set_attr "octave_class" "alu2op,alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true,true")])


(define_insn "subww_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "+rZ,rZ")
	 (ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					   (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 2)))
		 (ashift:SI (minus:HI 
			     (subreg:HI (match_dup 0) 0)
			     (subreg:HI (match_dup 1) 0))
			    (const_int 16))))
   (set (match_operand:SI 2 "memory_operand" "=S,S")
        (ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (clobber (reg:CC_NOOV  REG_ESS))]
  ""
  "@
   subww  %r1 %r0
   subwwi %1  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "subww,subwwi")
   (set_attr "octave_class" "alu2op,alu2op")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[2])"))
   (set_attr "linked_mem_update" "true,true")])


;
;
;
; SUBWW/SUBWWI Add Two Words 
;
; subww rsb rd [br=disp]
; subwwi usi rd [br=disp]
;
;

(define_insn "subww_br"
  [(set (pc)
	(if_then_else:HI (lt:HI (minus:HI 
				 (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 0)
				 (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 0))
				(const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (minus:HI
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (set (reg:CC_NOOV  REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					   (subreg:HI (match_dup 1) 2)))
		 (ashift:SI (zero_extend:SI (minus:HI
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16)))
	 (const_int 0)))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subww  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subww\");
	   return \"subww  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subwwi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwwi\");
	   return \"subwwi  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subww,subwwi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

(define_insn "subww_br_clobber"
  [(set (pc)
	(if_then_else:HI (lt:HI (minus:HI 
				 (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 0)
				 (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 0))
				(const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (minus:HI
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
   (clobber (reg:CC_NOOV  REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subww  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subww\");
	   return \"subww  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subwwi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwwi\");
	   return \"subwwi  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subww,subwwi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])


(define_insn "subww_br_lnk"
  [(set (pc)
	(if_then_else:HI (lt:HI (minus:HI 
				 (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 0)
				 (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 0))
				(const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 1) 0)
					    (subreg:HI (match_dup 2) 0)))
			   (const_int 16))))
   (set (reg:CC_NOOV  REG_ESS)
	(compare:CC_NOOV
	 (ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					   (subreg:HI (match_dup 1) 2)))
		 (ashift:SI (zero_extend:SI (minus:HI
					     (subreg:HI (match_dup 0) 0)
					     (subreg:HI (match_dup 1) 0)))
			    (const_int 16)))
	 (const_int 0)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subww  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subww\");
	   return \"subww  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subwwi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwwi\");
	   return \"subwwi  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subww,subwwi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

(define_insn "subww_br_lnk_clobber"
  [(set (pc)
	(if_then_else:HI (lt:HI (minus:HI 
				 (subreg:HI (match_operand:SI 0 "register_operand" "+rZ,rZ") 0)
				 (subreg:HI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M") 0))
				(const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (set (match_dup 0)
        (ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 1) 0)
					    (subreg:HI (match_dup 2) 0)))
			   (const_int 16))))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(ior:SI (zero_extend:SI (minus:HI (subreg:HI (match_dup 0) 2) 
					  (subreg:HI (match_dup 1) 2)))
		(ashift:SI (zero_extend:SI (minus:HI 
					    (subreg:HI (match_dup 0) 0)
					    (subreg:HI (match_dup 1) 0)))
			   (const_int 16))))
      (clobber (reg:CC_NOOV  REG_ESS))]
  ""
  "*
{
   switch (which_alternative)
     {
     case 0:
       if (get_attr_length(insn) == 1)
	 return \"subww  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subww\");
	   return \"subww  %1 %0\;bci %2 ESS30 %*\";
	 }
     case 1:
       if (get_attr_length(insn) == 1)
	 return \"subwwi  %1 %0 br=%2  %*\";
       else
	 {
	   branch_displacement_warning (insn, \"subwwi\");
	   return \"subwwi  %1 %0\;bci %2 ESS30 %*\";
	 }

     default:
       abort();
     }
}"
  [(set_attr "type" "alu2opbranch,alu2opbranch")
   (set_attr "instruction" "subww,subwwi")
   (set_attr "octave_class" "alu2opbranch,alu2opbranch")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")
   (set (attr "length")
	(if_then_else (and (ge (minus (match_dup 2) (pc))
				       (const_int -256))
				   (lt (minus (match_dup 2) (pc))
				       (const_int 255)))
		      (const_int 1)
		      (const_int 2)))])

;
;
; TCLRB: Test Bit Clear and Branch
;
;

(define_insn "tclrb_br"
  [(set (pc)
	(if_then_else:SI (eq:CCUNS 
			  (zero_extract:SI (match_operand:SI 0 "register_operand" "rZ")
					   (const_int 1)
					   (match_operand:SI 1 "c5bu_operand" "L"))
			  (const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   
   (set (reg:CCUNS REG_ESS)
        (eq:CCUNS (zero_extract:SI (match_dup 0)
				   (const_int 1)
				   (match_dup 1))
		  (const_int 0)))]
  ""
  "tclrb %r0 %1 br=%2 %>"
  [(set_attr "type" "tclrb")
   (set_attr "instruction" "tclrb")
   (set_attr "octave_class" "testbitbranch")])

(define_insn "tclrb_br_clobber"
  [(set (pc)
	(if_then_else:SI (eq:CCUNS 
			  (zero_extract:SI (match_operand:SI 0 "register_operand" "rZ")
					   (const_int 1)
					   (match_operand:SI 1 "c5bu_operand" "L"))
			  (const_int 0))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "tclrb %r0 %1 br=%2 %>"
  [(set_attr "type" "tclrb")
   (set_attr "instruction" "tclrb")
   (set_attr "octave_class" "testbitbranch")])

;;
;; for matching only
;;

(define_insn "tclrb_br_rev"
  [(set (pc)
	(if_then_else:SI (eq:CCUNS 
			  (zero_extract:SI (match_operand:SI 0 "register_operand" "rZ")
					   (const_int 1)
					   (match_operand:SI 1 "c5bu_operand" "L"))
			  (const_int 0))
			 (pc)
			 (match_operand 2 "immediate_operand" "")))
   (set (reg:CCUNS REG_ESS)
        (eq:CCUNS (zero_extract:SI (match_dup 0)
				   (const_int 1)
				   (match_dup 1))
		  (const_int 0)))]
  ""
  "tsetb %r0 %1 br=%2 %>"
  [(set_attr "type" "tclrb")
   (set_attr "instruction" "tclrb")
   (set_attr "octave_class" "testbitbranch")])

(define_insn "tclrb_br_rev_clobber"
  [(set (pc)
	(if_then_else:SI (eq:CCUNS 
			  (zero_extract:SI (match_operand:SI 0 "register_operand" "rZ")
					   (const_int 1)
					   (match_operand:SI 1 "c5bu_operand" "L"))
			  (const_int 0))
			 (pc)
			 (match_operand 2 "immediate_operand" "")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "tsetb %r0 %1 br=%2 %>"
  [(set_attr "type" "tclrb")
   (set_attr "instruction" "tclrb")
   (set_attr "octave_class" "testbitbranch")])

;
;
; TSETB: Test Bit Set and Branch
;
;

(define_insn "tsetb_br"
  [(set (pc)
	(if_then_else:SI (eq:CCUNS 
			  (zero_extract:SI (match_operand:SI 0 "register_operand" "rZ")
					   (const_int 1) 
					   (match_operand:SI 1 "c5bu_operand" "L"))
			  (const_int 1))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))

   (set (reg:CCUNS REG_ESS)
        (eq:CCUNS (zero_extract:SI (match_dup 0) 
				   (const_int 1)
				   (match_dup 1))
		  (const_int 1)))]
  ""
  "tsetb %r0 %1 br=%2 %>"
  [(set_attr "type" "tsetb")
   (set_attr "instruction" "tsetb")
   (set_attr "octave_class" "testbitbranch")])

(define_insn "tsetb_br_clobber"
  [(set (pc)
	(if_then_else:SI (eq:CCUNS 
			  (zero_extract:SI (match_operand:SI 0 "register_operand" "rZ")
					   (const_int 1) 
					   (match_operand:SI 1 "c5bu_operand" "L"))
			  (const_int 1))
			 (match_operand 2 "immediate_operand" "")
			 (pc)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "tsetb %r0 %1 br=%2 %>"
  [(set_attr "type" "tsetb")
   (set_attr "instruction" "tsetb")
   (set_attr "octave_class" "testbitbranch")])

;
; for matching only
;

(define_insn "tsetb_br_rev"
  [(set (pc)
	(if_then_else:SI (eq:CCUNS 
			  (zero_extract:SI (match_operand:SI 0 "register_operand" "rZ")
					   (const_int 1) 
					   (match_operand:SI 1 "c5bu_operand" "L"))
			  (const_int 1))
			 (pc)
			 (match_operand 2 "immediate_operand" "")))
   (set (reg:CCUNS REG_ESS)
        (eq:CCUNS (zero_extract:SI (match_dup 0) 
				   (const_int 1)
				   (match_dup 1))
		  (const_int 1)))]
  ""
  "tclrb %r0 %1 br=%2 %>"
  [(set_attr "type" "tsetb")
   (set_attr "instruction" "tsetb")
   (set_attr "octave_class" "testbitbranch")])

(define_insn "tsetb_br_rev_clobber"
  [(set (pc)
	(if_then_else:SI (eq:CCUNS 
			  (zero_extract:SI (match_operand:SI 0 "register_operand" "rZ")
					   (const_int 1) 
					   (match_operand:SI 1 "c5bu_operand" "L"))
			  (const_int 1))
			 (pc)
			 (match_operand 2 "immediate_operand" "")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "tclrb %r0 %1 br=%2 %>"
  [(set_attr "type" "tsetb")
   (set_attr "instruction" "tsetb")
   (set_attr "octave_class" "testbitbranch")])

;
; UNLINK: Unlink Implicit Registers
;

(define_insn "unlink"
  [(match_parallel 0 "any_operand"
		   [(use (match_operand:SI 1 "register_operand" "rZ"))])
   (match_operand:SI 2 "register_operand" "rZ")]
  ""
  "*
  {
    int words = XVECLEN (operands[0], 0);
    operands[2] = gen_rtx (REG, SImode, REGNO (operands[1]) + words - 1);
    return \"unlink  %1-%2\";
  }"
  [(set_attr "type" "unlink")
   (set_attr "instruction" "unlink")
   (set_attr "octave_class" "multiregop")])


;
;  XOR/XORI Add Registers 
;  XORI: Add Register w/ Immediate
;    
;  xor rsa rsb rd [MODX] [ABC]
;  xori rsa usi6 rd [ABC]
;

(define_insn "xor"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (xor:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
                 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(xor:SI (match_dup 1)
		(match_dup 2)))]
  ""
  "@
   xor  %r1 %r2 %r0
   xori %r1 %2  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "xor,xori")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")])

(define_insn "xor_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	 (xor:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
                 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   xor  %r1 %r2 %r0
   xori %r1 %2  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "xor,xori")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")])

(define_insn "xor_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (xor:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
                 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T"))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(xor:SI (match_dup 1)
		(match_dup 2)))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(xor:SI (match_dup 1)
		(match_dup 2)))]
  ""
  "@
   xor  %r1 %r2 %r0
   xori %r1 %2  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "xor,xori")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])

(define_insn "xor_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(xor:SI (match_operand:SI 1 "register_operand" "%rZ,rZ")
                 (match_operand:SI 2 "reg_or_10bs_operand" "rZ,T")))
   (set (match_operand:SI 3 "memory_operand" "=S,S")
	(xor:SI (match_dup 1)
		(match_dup 2)))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "@
   xor  %r1 %r2 %r0
   xori %r1 %2  %r0"
  [(set_attr "type" "arith,arith")
   (set_attr "instruction" "xor,xori")
   (set_attr "octave_class" "alu3opabcmod,alu3opabc")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[3])"))
   (set_attr "linked_mem_update" "true,true")])



(define_insn "xor_modx"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (xor:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (xor:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))]
  ""
  "xor  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "xor")
   (set_attr "octave_class" "alu3opabcmod")])



(define_insn "xor_modx_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (xor:SI
	   (and:SI (match_dup 1) 
		   (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "xor  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "xor")
   (set_attr "octave_class" "alu3opabcmod")])


(define_insn "xor_modx_lnk"
  [(set (reg:CCUNS REG_ESS)
	(compare:CCUNS
	 (ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (xor:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3))))
	 (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (xor:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (xor:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))]
  ""
  "xor  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "xor")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])


(define_insn "xor_modx_lnk_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(ior:SI 
	  (and:SI (match_operand:SI 1 "register_operand" "rZ")
		  (not:SI (match_operand:SI 3 "modx_operand" ""))) 
	  (xor:SI
	   (and:SI (match_dup 1) (match_dup 3))
	   (and:SI (match_operand:SI 2 "register_operand" "rZ") 
		   (match_dup 3)))))
   (set (match_operand:SI 4 "memory_operand" "=S")
	(ior:SI 
	 (and:SI (match_dup 1)
		 (not:SI (match_dup 3)))
	 (xor:SI
	  (and:SI (match_dup 1) (match_dup 3))
	  (and:SI (match_dup 2)
		  (match_dup 3)))))
   (clobber (reg:CCUNS REG_ESS))]
  ""
  "xor  %r1 %r2 %r0 %X3"
  [(set_attr "type" "logical")
   (set_attr "instruction" "xor")
   (set_attr "octave_class" "alu3opabcmod")
   (set (attr "memory_region")
	(symbol_ref "memory_region_p (operands[4])"))
   (set_attr "linked_mem_update" "true")])


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; C compiler specific patterns.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_expand "movsicc"
  [(set (match_operand:SI 0 "register_operand" "")
        (if_then_else:SI (match_operand 1 "comparison_operator" "")
                         (match_operand:SI 2 "register_operand" "")
                         (match_operand:SI 3 "reg_or_6bu_operand" "")))]
  ""
  "{ 
    enum rtx_code code = GET_CODE (operands[1]);
    rtx ccreg = m480_gen_compare_reg (code, m480_compare_op0, m480_compare_op1, 0);

    /* 
    
       The 4600 and up support an immediate operand for operand 3, the 4400 does not 
       unless it is the zero register 

    if (TARGET_4400 && (operands[3] != const0_rtx) && !register_operand(operands[3], SImode))
      operands[3] = force_reg (SImode, operands[3]);

    */

    emit_insn (gen_rtx_SET (SImode, operands[0],
                            gen_rtx_IF_THEN_ELSE (SImode,
                                 gen_rtx (code, VOIDmode, ccreg, const0_rtx),
                                          operands[2], operands[3])));
    DONE;
  }")

(define_expand "movsi"
  [(set (match_operand:SI 0 "nonimmediate_operand" "")
	(match_operand:SI 1 "general_operand" ""))]
  ""
  "
{
  /* Everything except mem = const or mem = mem can be done easily */
  if (GET_CODE (operands[0]) == MEM)
    operands[1] = force_reg (SImode, operands[1]);

  if (GET_CODE (operands[1]) == CONST_INT
      && !(reg_or_lim_operand (operands[1], SImode))) 
    {
      octave_split_constant (SET, SImode, INTVAL (operands[1]), operands[0],
			     NULL_RTX,
			     (reload_in_progress || reload_completed ? 0
			     : preserve_subexpressions_p ()));
      DONE;
    }

  if (symbol_operand(operands[1], SImode))
    {
      emit_insn(gen_movsi_addr32(operands[0], operands[1]));
      DONE;
    }
   
}")

(define_expand "movsi_addr32"
  [(set (match_dup 2)
	(high:SI (match_operand:SI 1 "immediate_operand" "")))
   (set (match_operand:SI 0 "register_operand" "")
	(lo_sum:SI (match_dup 2) (match_dup 1)))]
  ""
  "
{
  operands[2] = operands[0];
}")

(define_split
  [(set (match_operand:SI 0 "register_operand" "")
	(match_operand:SI 1 "symbol_operand" ""))]
  ""
  [(set (match_dup 0)
	(high:SI (match_dup 1)))
   (set (match_dup 0)
	(lo_sum:SI (match_dup 0)
		   (match_dup 1)))]
  "")

(define_insn "*movsi_test"
  [(set (reg:CC REG_ESS)
	(compare:CC (match_operand:SI 1 "reg_or_0_operand"  "rIZ")
		    (const_int 0)))
   (clobber (match_scratch:SI 0 "=rZ"))]
  ""
  "mv	%r1 %r0"
  [(set_attr "type" "arith")])


(define_split
  [(set (match_operand:SI 0 "s_register_operand" "")
	(match_operand:SI 1 "const_int_operand" ""))]
  "! (reg_or_lim_operand (operands[1], SImode))"
  [(clobber (const_int 0))]
  "
{
  old_octave_split_constant (SImode, INTVAL (operands[1]), operands[0], 0);
  DONE;
}")

 
(define_expand "movsf"
  [(set (match_operand:SF 0 "nonimmediate_operand" "")
        (match_operand:SF 1 "nonimmediate_operand" ""))]
  ""
  "
{
  if (GET_CODE (operands[1]) == CONST_DOUBLE)
    operands[1] = force_const_mem (SFmode, operands[1]);
  else if (GET_CODE (operands[0]) == MEM && GET_CODE(operands[1]) == MEM)
    operands[1] = force_reg (SFmode, operands[1]);
}")

(define_insn "*movsf_insn"
  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,r,m")
	(match_operand:SF 1 "nonimmediate_operand"  "rI,m,r"))]
  "(register_operand (operands[0], SFmode)
    || reg_or_0_operand (operands[1], SFmode))"
  "@
   cmov	%r1 %r1 %r0 ESS_BRALWAYS 
   lmm	%r0-%r0 %Y1 ; movsf
   smm	%r1-%r1 %Y0 ; movsf"
  [(set_attr "type" "cond_move,lmm_single,smm_single")])
 
(define_insn "add_for_unaligned"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(match_operand:SI 1 "register_operand" "%rZ")
		    (match_operand:SI 2 "const_int_operand" "")] ADD_FOR_UNALIGNED))]
  ""
  "addi %r1 %c2 %r0")

(define_expand "aligned_loadqi"
  [(set (match_operand:SI 3 "register_operand" "")
	(match_operand:SI 1 "memory_operand" ""))
   (set (subreg:SI (match_operand:QI 0 "register_operand" "") 0)
	(zero_extract:SI (subreg:SI (match_dup 3) 0)
			 (const_int 8)
			 (match_operand:SI 2 "const_int_operand" "")))]
  ""
  "")

(define_expand "aligned_loadhi"
  [(set (match_operand:SI 3 "register_operand" "")
	(match_operand:SI 1 "memory_operand" ""))
   (set (subreg:SI (match_operand:HI 0 "register_operand" "") 0)
	(zero_extract:SI (subreg:SI (match_dup 3) 0)
			 (const_int 16)
			 (match_operand:SI 2 "const_int_operand" "")))]
  ""
  "")
  
(define_expand "aligned_store"
  [(set (match_operand:SI 3 "register_operand" "")
	(match_operand:SI 0 "memory_operand" ""))

   (set (zero_extract:SI (match_dup 3)
			 (match_dup 4)
			 (match_operand:SI 2 "const_int_operand" ""))
	(subreg:SI (match_operand   1 "register_operand" "") 0))

   (set (match_dup 0)
	(match_dup 3))]
  ""
  "
{
  operands[4] = GEN_INT (GET_MODE_BITSIZE (GET_MODE (operands[1])));
}")


(define_expand "unaligned_loadqi"
  [; o0 = load
   (set (subreg:SI (match_operand:QI 0 "register_operand" "") 0)
	(mem:SI (and:SI (match_operand:SI 1 "address_operand" "")
			(const_int -4))))
   (set (match_operand:SI 2 "register_operand" "")
	(ashift:SI
	 (and:SI (match_dup 1)
		 (const_int 3))
	 (const_int 3)))
   (parallel [(set (subreg:SI (match_dup 0) 0)
		   (ashift:SI (subreg:SI (match_dup 0) 0)
			      (match_dup 2)))
	      (clobber (reg:CC REG_ESS))])
   (set (subreg:SI (match_dup 0) 0)
	(zero_extract:SI (subreg:SI (match_dup 0) 0)
			 (const_int 8)
			 (const_int 24)))]
  ""
  "")


(define_expand "unaligned_storeqi"
  [				 ; o2 = loaded data from store address
   (set (match_operand:SI 2 "register_operand" "")
	(mem:SI (and:SI (match_operand:SI 0 "address_operand" "")
			(const_int -4))))
   (set (match_operand:SI 3 "register_operand" "")
	(ashift:SI
	 (and:SI (match_dup 0)
		 (const_int 3))
	 (const_int 3)))
   (parallel [(set (match_dup 2)
		   (rotate:SI (match_dup 2) (match_dup 3)))
	      (clobber (reg:CC REG_ESS))])
   (set (zero_extract:SI (match_dup 2)
			 (const_int 8)
			 (const_int 24))
	(subreg:SI (match_operand:QI 1 "register_operand" "") 0))

   (parallel [(set (match_dup 3)
		   (umod:SI (neg:SI (match_dup 3))
			    (const_int 32)))
	      (clobber (reg:CC REG_ESS))])
   (parallel [(set (match_dup 3)
		   (rotate:SI (match_dup 2) (match_dup 3)))
	      (clobber (reg:CC REG_ESS))])
   (set (mem:SI (and:SI (match_dup 0) (const_int -4)))
	(match_dup 3))]

  ""
  "")

(define_expand "movqi"
  [(set (match_operand:QI 0 "general_operand" "")
        (match_operand:QI 1 "general_operand" ""))]
  ""
  "
{
  /*OCTAVE_RTX_DEBUG (operands[0], \"op0\"); OCTAVE_RTX_DEBUG (operands[1], \"op1\"); */

  /* If the output is not a register, the input must be.  */
  if (GET_CODE (operands[0]) == MEM)
     operands[1] = force_reg (QImode, operands[1]);

  /* Handle four memory cases, unaligned and aligned for either the input
     or the output.  The only case where we can be called during reload is
     for aligned loads; all other cases require temporaries.  */

  if (GET_CODE (operands[1]) == MEM
      || (GET_CODE (operands[1]) == SUBREG
	  && GET_CODE (SUBREG_REG (operands[1])) == MEM)
      || (reload_in_progress && REG_P (operands[1])
	  && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)
      || (reload_in_progress && GET_CODE (operands[1]) == SUBREG
	  && REG_P (SUBREG_REG (operands[1]))
	  && REGNO (SUBREG_REG (operands[1])) >= FIRST_PSEUDO_REGISTER))
    {
      /* Loads from memory */

      if (octave_aligned_memory_operand (operands[1], QImode))
	{
	  if (reload_in_progress)
	    {
	      emit_insn (gen_reload_inqi_help
		         (operands[0], operands[1],
			  gen_rtx_REG (SImode, REGNO (operands[0]))));
	    }
	  else
            {
	      rtx aligned_mem, bitnum;
	      rtx scratch = gen_reg_rtx (SImode);

	      octave_get_aligned_mem (operands[1], &aligned_mem, &bitnum);

	      emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,
					     scratch));
	    }
	}
      else
	{
	  /* (The alpha.md comment here is:
               Don-t pass temp reg setups as parameters since that makes the
               generated code depend on parameter evaluation order which will
               cause bootstrap failures.
             but since mxtgcc is a cross-compiler, is there a bootstrap to be
             concerned about?  -- Pres, 9 Sep 1999)  */

	  rtx temp2 = gen_reg_rtx (SImode);
	  rtx seq = gen_unaligned_loadqi (operands[0],
					  octave_get_unaligned_address (operands[1], 0),
					  temp2);

	  octave_set_memflags (seq, operands[1]);
	  emit_insn (seq);

	}

      DONE;
    }

  else if (GET_CODE (operands[0]) == MEM
	   || (GET_CODE (operands[0]) == SUBREG 
	       && GET_CODE (SUBREG_REG (operands[0])) == MEM)
	   || (reload_in_progress && REG_P (operands[0])
	       && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)
	   || (reload_in_progress && GET_CODE (operands[0]) == SUBREG
	       && REG_P (SUBREG_REG (operands[0]))
	       && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))
    {
      /* Stores to memory */

      if (octave_aligned_memory_operand (operands[0], QImode))
	{
	  rtx aligned_mem, bitnum;
	  rtx temp1 = gen_reg_rtx (SImode);

	  octave_get_aligned_mem (operands[0], &aligned_mem, &bitnum);

	  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum, temp1));
	}
      else
	{
	  rtx temp2 = gen_reg_rtx (SImode);
	  rtx temp3 = gen_reg_rtx (SImode);
	  rtx seq = gen_unaligned_storeqi (octave_get_unaligned_address (operands[0], 0),
					   operands[1],
					   temp2, temp3);
	  octave_set_memflags (seq, operands[0]);
	  emit_insn (seq);
	}
      DONE;
    }
  /*OCTAVE_RTX_DEBUG (operands[0], \"op0\"); OCTAVE_RTX_DEBUG (operands[1], \"op1\"); */
}")

(define_insn "movqi_insn"
  [(set (match_operand:QI 0 "register_operand" "=rZ,rZ")
	(match_operand:QI 1 "nonmemory_operand"  "rIZ,R"))]
  ""
  "*
{
  switch (which_alternative)
    {
    case 0:
      return \"cmov	%r1 %r1 %r0 ESS_BRALWAYS \";

    case 1:
      if (CONST_OK_FOR_UI_17BITS (INTVAL (operands[1])))
	return \"lil	%r0 %c1\";
      else
	return \"lih	%r0 hi16(%c1)\";

    default:
       return \"movqi_insn: invalid_alternative\";
    }
}"
  [(set_attr "type" "cond_move,lil_or_lih")
   (set_attr "instruction" "cmov,lil")
   (set_attr "octave_class" "cmovop,loadop")])

(define_expand "unaligned_loadhi"
  [; o0 = load

   (set (subreg:SI (match_operand:HI 0 "register_operand" "") 0)
	(mem:SI (and:SI (match_operand:SI 1 "address_operand" "")
			(const_int -4))))

; --- note that halfword0==bits31:16 at (addr mod 4 = 0) left-aligned
;     and halfword1==bits15:0 at (addr mod 4 = 2) needs 16bits shift

; o2 = (o1&2)*8 --- becomes shift distance either 16 or 0
   (set (match_operand:SI 2 "register_operand" "")
	(ashift:SI
	 (and:SI (match_dup 1)
		 (const_int 3))
	 (const_int 3)))


; o0 = (o0_data << o2)
   (parallel [(set (subreg:SI (match_dup 0) 0)
		   (ashift:SI (subreg:SI (match_dup 0) 0)
			      (match_dup 2)))
	      (clobber (reg:CC REG_ESS))])

; o0 = (o0 & 0xffff0000) >> 16
   (set (subreg:SI (match_dup 0) 0)
	(zero_extract:SI (subreg:SI (match_dup 0) 0)
			 (const_int 16)
			 (const_int 16)))]
  ""
  "")

(define_expand "unaligned_storehi"
  [				 ; o2 = loaded data from store address
   (set (match_operand:SI 2 "register_operand" "")
	(mem:SI (and:SI (match_operand:SI 0 "address_operand" "")
			(const_int -4))))

; o3 = addr+2 --- note that halfword0==bits31:16 at (addr mod 4 = 0) needs 16bits rotate
;                     and halfword1==bits15:0 at (addr mod 4 = 2) already right-aligned
;              (See the 'and'-effect of the zero_extract, below)

   (set (match_operand:SI 3 "register_operand" "")
	(ashift:SI
	 (and:SI (match_dup 0)
		 (const_int 3))
	 (const_int 3)))

; o5_positioned = (o2_origdata .rotate_left. o4_dist)
   (parallel [(set (match_dup 2)
		   (rotate:SI (match_dup 2) (match_dup 3)))
	      (clobber (reg:CC REG_ESS))])

; o5_newd = (upper 16 o5_positioned, lower 16 o1_newdata)
   (set (zero_extract:SI (match_dup 2)
			 (const_int 16)
			 (const_int 16))
	(subreg:SI (match_operand:HI 1 "register_operand" "") 0))

   (parallel [(set (match_dup 3)
		   (umod:SI (neg:SI (match_dup 3))
			    (const_int 32)))
	      (clobber (reg:CC REG_ESS))])

; o6_newd_repositioned = (o5_newd .rotate_left. o4_dist)
   (parallel [(set (match_dup 2)
		   (rotate:SI (match_dup 2) (match_dup 3)))
	      (clobber (reg:CC REG_ESS))])

; mem = o6
   (set (mem:SI (and:SI (match_dup 0) (const_int -4)))
	(match_dup 2))]

  ""
  "")

(define_expand "movhi"
  [(set (match_operand:HI 0 "general_operand" "")
        (match_operand:HI 1 "general_operand" ""))]
  ""
  "
{
  /*OCTAVE_RTX_DEBUG (operands[0], \"op0\"); OCTAVE_RTX_DEBUG (operands[1], \"op1\"); */

  /* If the output is not a register, the input must be.  */
  if (GET_CODE (operands[0]) == MEM)
     operands[1] = force_reg (HImode, operands[1]);

  /* Handle four memory cases, unaligned and aligned for either the input
     or the output.  The only case where we can be called during reload is
     for aligned loads; all other cases require temporaries.  */

  if (GET_CODE (operands[1]) == MEM
      || (GET_CODE (operands[1]) == SUBREG
	  && GET_CODE (SUBREG_REG (operands[1])) == MEM)
      || (reload_in_progress && REG_P (operands[1])
	  && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)
      || (reload_in_progress && GET_CODE (operands[1]) == SUBREG
	  && REG_P (SUBREG_REG (operands[1]))
	  && REGNO (SUBREG_REG (operands[1])) >= FIRST_PSEUDO_REGISTER))
    {
      /* Loads from memory */

      if (octave_aligned_memory_operand (operands[1], HImode))
	{
	  if (reload_in_progress)
	    {
	      emit_insn (gen_reload_inhi_help
		         (operands[0], operands[1],
			  gen_rtx_REG (SImode, REGNO (operands[0]))));
	    }
	  else
	    {
	      rtx aligned_mem, bitnum;
	      rtx scratch = gen_reg_rtx (SImode);

	      octave_get_aligned_mem (operands[1], &aligned_mem, &bitnum);

	      emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,
					     scratch));
	    }
	}
      else
	{
	  /* (The alpha.md comment here is:
               Don-t pass temp reg setups as parameters since that makes the
               generated code depend on parameter evaluation order which will
               cause bootstrap failures. 
             but since mxtgcc is a cross-compiler, is there a bootstrap to be
             concerned about?  -- Pres, 9 Sep 1999)  */

	  rtx temp2 = gen_reg_rtx (SImode);
	  rtx seq = gen_unaligned_loadhi (operands[0],
					  octave_get_unaligned_address (operands[1], 0),
		                          temp2);

	octave_set_memflags (seq, operands[1]);
	emit_insn (seq);

	}

      DONE;
    }

  else if (GET_CODE (operands[0]) == MEM
	   || (GET_CODE (operands[0]) == SUBREG 
	       && GET_CODE (SUBREG_REG (operands[0])) == MEM)
	   || (reload_in_progress && REG_P (operands[0])
	       && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)
	   || (reload_in_progress && GET_CODE (operands[0]) == SUBREG
	       && REG_P (SUBREG_REG (operands[0]))
	       && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))
    {
      /* Stores to memory */

      if (octave_aligned_memory_operand (operands[0], HImode))
	{
	  rtx aligned_mem, bitnum;
	  rtx temp1 = gen_reg_rtx (SImode);

	  octave_get_aligned_mem (operands[0], &aligned_mem, &bitnum);

	  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum, temp1));
	}
      else
	{
	  rtx temp2 = gen_reg_rtx (SImode);
	  rtx temp3 = gen_reg_rtx (SImode);
	  rtx seq = gen_unaligned_storehi (octave_get_unaligned_address (operands[0], 0),
					   operands[1],
					   temp2, temp3);
	  octave_set_memflags (seq, operands[0]);
	  emit_insn (seq);
	}
      DONE;
    }
  /*OCTAVE_RTX_DEBUG (operands[0], \"op0\"); OCTAVE_RTX_DEBUG (operands[1], \"op1\"); */
}")


(define_insn "movhi_insn"
  [(set (match_operand:HI 0 "register_operand" "=rZ,rZ")
	(match_operand:HI 1 "nonmemory_operand"  "rIZ,R"))]
  ""
  "*
{
  switch (which_alternative)
    {
    case 0:
      return \"cmov	%r1 %r1 %r0 ESS_BRALWAYS \";

    case 1:
      if (CONST_OK_FOR_UI_17BITS (INTVAL (operands[1])))
	return \"lil	%r0 %c1\";
      else
	return \"lih	%r0 hi16(%c1)\";

    default:
        return \"movhi_insn: invalid alternative\";
    }
}"
  [(set_attr "type" "cond_move,lil_or_lih")
   (set_attr "instruction" "cmov,lil")
   (set_attr "octave_class" "cmovop,loadop")])

(define_expand "reload_inqi"
  [(parallel [(match_operand:QI 0 "register_operand" "=rZ")
	      (match_operand:QI 1 "any_memory_operand" "m")
	      (match_operand:DI 2 "register_operand" "=&rZ")])]
  ""
  "
{
  rtx scratch, seq;

  if (GET_CODE (operands[1]) != MEM)
    abort ();

  if (octave_aligned_memory_operand (operands[1], QImode))
    {
      seq = gen_reload_inqi_help (operands[0], operands[1],
				  gen_rtx_REG (SImode, REGNO (operands[2])));
    }
  else
    {
      rtx addr;

      /* It is possible that one of the registers we got for operands[2]
	 might coincide with that of operands[0] (which is why we made
	 it DImode).  Pick the other one to use as our scratch.  */

      if (REGNO (operands[0]) == REGNO (operands[2]))
	scratch = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);
      else
	scratch = gen_rtx_REG (SImode, REGNO (operands[2]));


      addr = octave_get_unaligned_address (operands[1], 0);
      seq = gen_unaligned_loadqi (operands[0], addr, scratch);
      octave_set_memflags (seq, operands[1]);
    }
  emit_insn (seq);
  DONE;
}")

(define_expand "reload_inhi"
  [(parallel [(match_operand:HI 0 "register_operand" "=rZ")
	      (match_operand:HI 1 "any_memory_operand" "m")
	      (match_operand:DI 2 "register_operand" "=&rZ")])]
  ""
  "
{
  rtx scratch, seq;

  if (GET_CODE (operands[1]) != MEM)
    abort ();

  if (octave_aligned_memory_operand (operands[1], HImode))
    {
      seq = gen_reload_inhi_help (operands[0], operands[1], 
				  gen_rtx_REG (SImode, REGNO (operands[2])));
    }
  else
    {
      rtx addr;

      /* It is possible that one of the registers we got for operands[2]
	 might coincide with that of operands[0] (which is why we made
	 it DImode).  Pick the other one to use as our scratch.  */

      if (REGNO (operands[0]) == REGNO (operands[2]))
	scratch = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);
      else
	scratch = gen_rtx_REG (SImode, REGNO (operands[2]));

      addr = octave_get_unaligned_address (operands[1], 0);
      seq = gen_unaligned_loadhi (operands[0], addr, scratch);

      octave_set_memflags (seq, operands[1]);
    }
  emit_insn (seq);
  DONE;
}")

(define_expand "reload_outqi"
  [(parallel [(match_operand:QI 0 "any_memory_operand" "=m")
	      (match_operand:QI 1 "register_operand" "rZ")
	      (match_operand:DI 2 "register_operand" "=&rZ")])]
  ""
  "
{
  if (GET_CODE (operands[0]) != MEM)
    abort ();

  if (octave_aligned_memory_operand (operands[0], QImode))
    {
      emit_insn (gen_reload_outqi_help
		 (operands[0], operands[1],
		  gen_rtx_REG (SImode, REGNO (operands[2]))));
    }
  else
    {
      rtx addr = octave_get_unaligned_address (operands[0], 0);
      rtx scratch1 = gen_rtx_REG (SImode, REGNO (operands[2]));
      rtx scratch2 = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);
      rtx seq;

      seq = gen_unaligned_storeqi (addr, operands[1], scratch1,
				   scratch2);
      octave_set_memflags (seq, operands[0]);
      emit_insn (seq);
    }
  DONE;
}")

(define_expand "reload_outhi"
  [(parallel [(match_operand:HI 0 "any_memory_operand" "=m")
	      (match_operand:HI 1 "register_operand" "rZ")
	      (match_operand:DI 2 "register_operand" "=&rZ")])]
  ""
  "
{
  if (GET_CODE (operands[0]) != MEM)
    abort ();

  if (octave_aligned_memory_operand (operands[0], HImode))
    {
      emit_insn (gen_reload_outhi_help
		 (operands[0], operands[1],
		  gen_rtx_REG (SImode, REGNO (operands[2]))));
    }
  else
    {
      rtx addr = octave_get_unaligned_address (operands[0], 0);
      rtx scratch1 = gen_rtx_REG (SImode, REGNO (operands[2]));
      rtx scratch2 = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);
      rtx seq;

      seq = gen_unaligned_storehi (addr, operands[1], scratch1,
				   scratch2);
      octave_set_memflags (seq, operands[0]);
      emit_insn (seq);
    }
  DONE;
}")


(define_insn "save_ess"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(reg:CC REG_ESS)] SAVE_ESS))]
  "(reload_in_progress | reload_completed)"
  "mvhr	r66 %r0	;Save ess"
  [(set_attr "type" "move_hardware")
   (set_attr "instruction" "mvhr")
   (set_attr "octave_class" "mvop")])

(define_insn "restore_ess"
  [(set (reg:CC REG_ESS)
	(unspec:CC [(match_operand:SI 0 "register_operand" "rZ")] RESTORE_ESS))]
  "(reload_in_progress | reload_completed)"
  "mvrh	%r0 r66	;Restore ess"
  [(set_attr "type" "move_hardware")
   (set_attr "instruction" "mvrh")
   (set_attr "octave_class" "mvop")])

(define_insn "add_for_reload"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(unspec:SI [(match_operand:SI 1 "register_operand" "%rZ")
		    (match_operand:SI 2 "register_operand" "rZ")] ADD_FOR_RELOAD))
   (use (match_operand:SI 3 "register_operand" "rZ"))
   (clobber (reg:CC REG_ESS))]
  "(reload_in_progress | reload_completed)"
  "add	%r1 %r2 %r0 ;Add for reload"
  [(set_attr "type" "arith")
   (set_attr "instruction" "add")
   (set_attr "octave_class" "alu3op")])

(define_expand "reload_insi"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
	(match_operand:SI 1 "ess_clobbering_plus_operand" ""))
   (clobber (match_operand:DI 2 "register_operand" "=&rZ"))]
  ""
  "
{
  rtx scratch;

  rtx op1 = XEXP (operands[1], 0);
  rtx op2 = XEXP (operands[1], 1);

  /* It is possible that one of the registers we got for operands[2]
     might coincide with that of operands[0] (which is why we made
     it DImode).  Pick the other one to use as our scratch.  */

  if (REGNO (operands[0]) == REGNO (operands[2]))
    scratch = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);
  else
    scratch = gen_rtx_REG (SImode, REGNO (operands[2]));

  emit_insn (gen_save_ess(scratch));
  emit_move_insn (operands[0], op2);
  emit_insn (gen_add_for_reload(operands[0], operands[0], op1, scratch));
  emit_insn (gen_restore_ess(scratch));
  DONE;
}")

(define_insn "reload_inqi_help"
  [(set (match_operand:QI 0 "register_operand" "=rZ")
        (match_operand:QI 1 "memory_operand" "m"))
   (clobber (match_operand:SI 2 "register_operand" "=rZ"))]
  "(reload_in_progress || reload_completed)"
  "#")

(define_insn "reload_inhi_help"
  [(set (match_operand:HI 0 "register_operand" "=rZ")
        (match_operand:HI 1 "memory_operand" "m"))
   (clobber (match_operand:SI 2 "register_operand" "=rZ"))]
  "(reload_in_progress || reload_completed)"
  "#")

(define_insn "reload_outqi_help"
  [(set (match_operand:QI 0 "memory_operand" "=m")
        (match_operand:QI 1 "register_operand" "rZ"))
   (clobber (match_operand:SI 2 "register_operand" "=rZ"))]
  ""
  "#")

(define_insn "reload_outhi_help"
  [(set (match_operand:HI 0 "memory_operand" "=m")
        (match_operand:HI 1 "register_operand" "rZ"))
   (clobber (match_operand:SI 2 "register_operand" "=rZ"))]
  ""
  "#")

(define_split
  [(set (match_operand:QI 0 "register_operand" "")
        (match_operand:QI 1 "memory_operand" ""))
   (clobber (match_operand:SI 2 "register_operand" ""))]
  "reload_completed"
  [(const_int 0)]
  "
{
  rtx aligned_mem, bitnum;
  octave_get_aligned_mem (operands[1], &aligned_mem, &bitnum);
  emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,
				 operands[2]));
  DONE;
}")

(define_split
  [(set (match_operand:HI 0 "register_operand" "")
        (match_operand:HI 1 "memory_operand" ""))
   (clobber (match_operand:SI 2 "register_operand" ""))]
  "reload_completed"
  [(const_int 0)]
  "
{
  rtx aligned_mem, bitnum;
  octave_get_aligned_mem (operands[1], &aligned_mem, &bitnum);
  emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,
				 operands[2]));
  DONE;
}")

(define_split
  [(set (match_operand:QI 0 "memory_operand" "")
        (match_operand:QI 1 "register_operand" ""))
   (clobber (match_operand:SI 2 "register_operand" ""))]
  "reload_completed"
  [(const_int 0)]
  "
{
  rtx aligned_mem, bitnum;
  octave_get_aligned_mem (operands[0], &aligned_mem, &bitnum);
  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,
				operands[2]));
  DONE;
}")

(define_split
  [(set (match_operand:HI 0 "memory_operand" "")
        (match_operand:HI 1 "register_operand" ""))
   (clobber (match_operand:SI 2 "register_operand" ""))]
  "reload_completed"
  [(const_int 0)]
  "
{
  rtx aligned_mem, bitnum;
  octave_get_aligned_mem (operands[0], &aligned_mem, &bitnum);
  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,
				operands[2]));
  DONE;
}")

(define_expand "addsi3"
  [(parallel [(set (match_operand:SI 0 "register_operand" "")
		   (plus:SI (match_operand:SI 1 "reg_or_0_operand" "")
			    (match_operand:SI 2 "reg_or_lim_operand" "")))
	      (clobber (reg:CC REG_ESS))])]
  ""
  "
{
  if (octave_emit_add_sequence (operands, SImode))
    DONE;
}")

(define_insn "addsi3_noclobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
 	(plus:SI (match_operand:SI 1 "register_operand" "%0")
		 (match_operand:SI 2 "lim_operand" "R")))]
  ""
  "*
 {
   if (CONST_OK_FOR_UI_17BITS (INTVAL (operands[2])))
     return \"lail	%r0 %c2\";
   else
     return \"laih	%r0 hi16(%c2)\";
 }"
  [(set_attr "type" "lail_or_laih")])

(define_expand "subsi3"
  [(parallel [(set (match_operand:SI 0 "register_operand" "")
		   (minus:SI (match_operand:SI 1 "reg_or_0_operand" "")
			     (match_operand:SI 2 "reg_or_6bu_operand" "")))
	      (clobber (reg:CC REG_ESS))])]
  ""
  "
{
  if (GET_CODE (operands[2]) == CONST_INT && !reg_or_6bu_operand (operands[2], SImode))
    {
      operands[2] = force_reg(SImode, operands[2]);
    }
}")

(define_expand "mulsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(mult:SI (match_operand:SI 1 "register_operand" "")
		 (match_operand:SI 2 "register_operand" "")))]
  ""
  "
{
  if (!REG_P (operands[2]))
    {
      operands[2] = force_reg(SImode, operands[2]);
    }
}")

(define_expand "uminsi3"
  [(parallel [(set (match_operand:SI 0 "register_operand" "")
		   (umin:SI (match_operand:SI 1 "register_operand" "")
			    (match_operand:SI 2 "reg_or_10bs_operand" "")))
	      (clobber (reg:CCUNS REG_ESS))])]
  ""
  "")

(define_expand "umaxsi3"
  [(parallel [(set (match_operand:SI 0 "register_operand" "")
		   (umax:SI (match_operand:SI 1 "register_operand" "")
			    (match_operand:SI 2 "reg_or_10bs_operand" "")))
	      (clobber (reg:CCUNS REG_ESS))])]
  ""
  "")


(define_expand "andsi3"
  [(parallel [(set (match_operand:SI 0 "register_operand" "")
		   (and:SI (match_operand:SI 1 "reg_or_0_operand" "")
			   (match_operand:SI 2 "reg_or_10bs_operand" "")))
	      (clobber (reg:CC REG_ESS))])]
  ""
  "
{
  if (!reg_or_10bs_operand (operands[2], SImode) 
      && !mod_mask_operand(operands[2], SImode))
    {
      operands[2] = force_reg(SImode, operands[2]);
    }
}")


(define_expand "iorsi3"
  [(parallel [(set (match_operand:SI 0 "register_operand" "")
		   (ior:SI (match_operand:SI 1 "reg_or_0_operand" "")
			   (match_operand:SI 2 "reg_or_10bs_operand" "")))
	      (clobber (reg:CC REG_ESS))])]
  ""
  "
{
  if (!reg_or_10bs_operand (operands[2], SImode))
    {
      operands[2] = force_reg(SImode, operands[2]);
    }
}")


(define_expand "xorsi3"
  [(parallel [(set (match_operand:SI 0 "register_operand" "")
		   (xor:SI (match_operand:SI 1 "reg_or_0_operand" "")
			   (match_operand:SI 2 "reg_or_10bs_operand" "")))
	      (clobber (reg:CC REG_ESS))])]
  ""
  "
{
  if (!reg_or_10bs_operand (operands[2], SImode))
    {
      operands[2] = force_reg(SImode, operands[2]);
    }
}")


(define_expand "ashlsi3"
  [(parallel [(set (match_operand:SI 0 "register_operand" "")
		   (ashift:SI (match_operand:SI 1 "reg_or_0_operand" "")
			      (match_operand:SI 2 "reg_or_5bu_operand" "")))
	      (clobber (reg:CC REG_ESS))])]
  ""
  "")


(define_expand "ashrsi3"
  [(parallel [(set (match_dup 3)
		   (neg:SI (match_operand:SI 2 "register_operand" "")))
	      (clobber (reg:CC REG_ESS))])
   (parallel [(set (match_operand:SI 0 "register_operand" "")
		   (ashiftrt:SI (match_operand:SI 1 "register_operand" "")
				(match_dup 3)))
	      (clobber (reg:CC REG_ESS))])]
  ""
  "
{
}")

(define_expand "lshrsi3"
  [(parallel [(set (match_dup 3)
		   (neg:SI (match_operand:SI 2 "register_operand" "")))
	      (clobber (reg:CC REG_ESS))])
   (parallel [(set (match_operand:SI 0 "register_operand" "")
		   (lshiftrt:SI (match_operand:SI 1 "reg_or_0_operand" "")
				(match_dup 3)))
	      (clobber (reg:CC REG_ESS))])]
  ""
  "
{
}")


(define_split
  [(set (match_operand:SI 0 "register_operand" "")
	(ashift:SI (and:SI (match_operand:SI 1 "register_operand" "")
			   (const_int 3))
		   (const_int 3)))]
  ""
  [(parallel [(set (match_dup 0) 
		   (and:SI (match_dup 1) (const_int 3)))
	      (clobber (reg:CC REG_ESS))])
   (parallel [(set (match_dup 0)
		   (ashift:SI (match_dup 0)
			      (const_int 3)))
	      (clobber (reg:CC REG_ESS))])]
  "")



(define_expand "negsi2"
  [(parallel [(set (match_operand:SI 0 "register_operand" "")
		   (neg:SI (match_operand:SI 1 "reg_or_6bu_operand" "")))
	      (clobber (reg:CC REG_ESS))])]
  ""
  "")

(define_insn "negsi2_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(neg:SI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M")))
   (clobber (reg:CC REG_ESS))]
  ""
  "@
   sub	ZERO %r1 %r0   ; (negate)
   subi	ZERO %1 %r0"
  [(set_attr "type" "arith,arith")])

(define_insn "*negsi3_test"
  [(set (reg:CC REG_ESS)
	(compare:CC (neg:SI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M"))
		    (const_int 0)))
   (clobber (match_scratch:SI 0 "=rZ,rZ"))]
  ""
  "@
   sub	ZERO %r1 %r0   ; (negate)
   subi	ZERO %1 %r0"
  [(set_attr "type" "arith,arith")])

(define_insn "*negsi3_set"
  [(set (reg:CC REG_ESS)
	(compare:CC (neg:SI (match_operand:SI 1 "reg_or_6bu_operand" "rZ,M"))
		    (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ,rZ")
	(neg:SI (match_dup 1)))]
  ""
  "@
   sub	ZERO %r1 %r0   ; (negate)
   subi	ZERO %1 %r0"
  [(set_attr "type" "arith,arith")])

(define_expand "negsf2"
  [(set (match_operand:SF 0 "register_operand" "")
	(neg:SF (match_operand:SF 1 "register_operand" "")))]
  ""
  "
{
  rtx result;
  rtx target;

  target = operand_subword_force (operands[0], 0, SFmode);
  result = expand_binop (SImode, xor_optab,
			 operand_subword_force (operands[1], 0, SFmode),
			 GEN_INT(0x80000000), target, 0, OPTAB_WIDEN);
  if (result == 0)
    abort ();

  if (result != target)
    emit_move_insn (result, target);

  /* Make a place for REG_EQUAL.  */
  emit_move_insn (operands[0], operands[0]);
  DONE;
}")


(define_expand "one_cmplsi2"
  [(parallel [(set (match_operand:SI 0 "register_operand" "=rZ")
		   (not:SI (match_operand:SI 1 "register_operand" "rZ")))
	      (clobber (reg:CC REG_ESS))])]
  ""
  "")

(define_insn "one_cmplsi2_clobber"
  [(set (match_operand:SI 0 "register_operand" "=rZ")
        (not:SI (match_operand:SI 1 "register_operand" "rZ")))
   (clobber (reg:CC REG_ESS))]
  ""
  "xori %1 -1 %0"
  [(set_attr "type" "logical")])

(define_insn "*one_cmplsi2_test"
  [(set (reg:CC REG_ESS)
	(compare:CC (not:SI (match_operand:SI 1 "register_operand" "rZ"))
		    (const_int 0)))
   (clobber (match_scratch:SI 0 "=rZ"))]
  ""
  "xori %1 -1 %0"
  [(set_attr "type" "logical")])

(define_insn "*one_cmplsi2_set"
  [(set (reg:CC REG_ESS)
	(compare:CC (not:SI (match_operand:SI 1 "register_operand" "rZ"))
		    (const_int 0)))
   (set (match_operand:SI 0 "register_operand" "=rZ")
	(not:SI (match_dup 1)))]
  ""
  "xori %1 -1 %0"
  [(set_attr "type" "logical")])

(define_expand "cmpsi"
  [(set (reg:CC REG_ESS)
	(compare:CC (match_operand:SI 0 "register_operand" "")
		    (match_operand:SI 1 "nonmemory_operand" "")))]
  ""
  "
{
  m480_compare_op0 = operands[0];
  m480_compare_op1 = operands[1];
  DONE;
}")


(define_insn "cmpsi_internal2"
  [(set (reg:CC REG_ESS) 
	(compare:CC (match_operand:SI 0 "register_operand" "rZ,rZ")
		    (match_operand:SI 1 "reg_or_6bs_operand" "rZ,M")))]
  ""
  "@
   sub	%r0 %r1 ZERO ;    cmpsi insn
   subi	%r0 %1 ZERO ;    cmpsi insn"
  [(set_attr "type" "compare,compare")])

(define_insn "cmphi_internal"
  [(set (reg:CC REG_ESS) 
	(compare:CC (match_operand:HI 0 "register_operand" "rZ")
		    (const_int 0)))]
  ""
  "or	ZERO %r0 ZERO MOD64K;    cmphi insn"
  [(set_attr "type" "compare")])

(define_insn "cmpqi_internal"
  [(set (reg:CC REG_ESS) 
	(compare:CC (match_operand:QI 0 "register_operand" "rZ")
		    (const_int 0)))]
  ""
  "or	ZERO %r0 ZERO MOD256;    cmpqi insn"
  [(set_attr "type" "compare")])


(define_expand "load_multiple"
  [(match_par_dup 3 [(set (match_operand:SI 0 "" "")
			  (match_operand:SI 1 "" ""))
		     (use (match_operand:SI 2 "" ""))])]
  ""
  "
{
  rtx from;
 
  /* Support only loading a constant number of fixed-point registers from
     memory */
  if (GET_CODE (operands[2]) != CONST_INT
      || INTVAL (operands[2]) <= 1
      || INTVAL (operands[2]) > 16
      || GET_CODE (operands[1]) != MEM
      || GET_CODE (operands[0]) != REG)
    FAIL;

  if (!(reload_in_progress || reload_completed))
    from = force_reg (SImode, XEXP (operands[1], 0));
  else
    from = XEXP (operands[1], 0);
  
  operands[3]
    = m480_gen_load_multiple (REGNO (operands[0]), INTVAL (operands[2]),
				 from,
				 TRUE, FALSE, RTX_UNCHANGING_P(operands[1]),
				 MEM_IN_STRUCT_P(operands[1]),
				 MEM_SCALAR_P (operands[1]));
}")
 

(define_expand "store_multiple"
  [(match_par_dup 3 [(set (match_operand:SI 0 "" "")
			  (match_operand:SI 1 "" ""))
		     (use (match_operand:SI 2 "" ""))])]
  ""
  "
{
  rtx to;

  /* Support only storing a constant number of fixed-point registers to
     memory and only bother with this if more than two; the machine
     doesn't support more than sixteen.  */
  if (GET_CODE (operands[2]) != CONST_INT
      || INTVAL (operands[2]) < 2
      || INTVAL (operands[2]) > 16
      || GET_CODE (operands[0]) != MEM
      || GET_CODE (operands[1]) != REG)
    FAIL;

  if (!(reload_in_progress || reload_completed))
    to = force_reg (SImode, XEXP (operands[0], 0));
  else
    to = XEXP (operands[0], 0);

  operands[3]
    = m480_gen_store_multiple (REGNO (operands[1]), INTVAL (operands[2]),
				  to,
				  TRUE, FALSE, RTX_UNCHANGING_P (operands[0]),
				  MEM_IN_STRUCT_P(operands[0]), 
				  MEM_SCALAR_P (operands[0]));
}")

(define_expand "movstrqi"
  [(match_operand:BLK 0 "general_operand" "")
   (match_operand:BLK 1 "general_operand" "")
   (match_operand:SI 2 "const_int_operand" "")
   (match_operand:SI 3 "const_int_operand" "")]
  ""
  "
  if (m480_gen_movstrqi (operands))
    DONE;
  FAIL;
")

(define_expand "clrstrqi"
  [(parallel [(set (match_operand:BLK 0 "memory_operand" "")
		   (const_int 0))
	      (use (match_operand:SI 1 "const_int_operand" ""))
	      (use (match_operand:SI 2 "const_int_operand" ""))])]
  ""
  "
{
  if (m480_gen_clrstrqi (operands))
    DONE;
  else
    FAIL;
}")

(define_expand "beq"
  [(set (pc)
	(if_then_else (eq (match_dup 1)
			  (const_int 0))
		      (match_operand 0 "immediate_operand" "")
		      (pc)))]
  ""
  "
{ 
  m480_gen_compare_and_branch (EQ, m480_compare_op0, m480_compare_op1, 0, operands[0]); 
  DONE;
}")

(define_expand "bne"
  [(set (pc)
	(if_then_else (ne (match_dup 1)
			  (const_int 0))
		      (match_operand 0 "immediate_operand" "")
		      (pc)))]
  ""
  "
{ 
  m480_gen_compare_and_branch (NE, m480_compare_op0, m480_compare_op1, 0, operands[0]); 
  DONE;
}")

(define_expand "bgt"
  [(set (pc)
	(if_then_else (gt (match_dup 1)
			  (const_int 0))
		      (match_operand 0 "immediate_operand" "")
		      (pc)))]
  ""
  "
{ 
  m480_gen_compare_and_branch (GT, m480_compare_op0, m480_compare_op1, 0, operands[0]); 
  DONE;
}")

(define_expand "bgtu"
  [(set (pc)
	(if_then_else (gtu (match_dup 1)
			   (const_int 0))
		      (match_operand 0 "immediate_operand" "")
		      (pc)))]
  ""
  "
{ 
  m480_gen_compare_and_branch (GTU, m480_compare_op0, m480_compare_op1, 0, operands[0]); 
  DONE;
}")

(define_expand "blt"
  [(set (pc)
	(if_then_else (lt (match_dup 1)
			  (const_int 0))
		      (match_operand 0 "immediate_operand" "")
		      (pc)))]
  ""
  "
{ 
  m480_gen_compare_and_branch (LT, m480_compare_op0, m480_compare_op1, 0, operands[0]);
  DONE;
}")

(define_expand "bltu"
  [(set (pc)
	(if_then_else (ltu (match_dup 1)
			   (const_int 0))
		      (match_operand 0 "immediate_operand" "")
		      (pc)))]
  ""
  "
{ 
  m480_gen_compare_and_branch (LTU, m480_compare_op0, m480_compare_op1, 0, operands[0]);
  DONE;
}")

(define_expand "bge"
  [(set (pc)
	(if_then_else (ge (match_dup 1)
			  (const_int 0))
		      (match_operand 0 "immediate_operand" "")
		      (pc)))]
  ""
  "
{
  m480_gen_compare_and_branch (GE, m480_compare_op0, m480_compare_op1, 0, operands[0]);
  DONE;
}")

(define_expand "bgeu"
  [(set (pc)
	(if_then_else (geu (match_dup 1)
			   (const_int 0))
		      (match_operand 0 "immediate_operand" "")
		      (pc)))]
  ""
  "
{
  m480_gen_compare_and_branch (GEU, m480_compare_op0, m480_compare_op1, 0, operands[0]);
  DONE;
}")

(define_expand "ble"
  [(set (pc)
	(if_then_else (le (match_dup 1)
			  (const_int 0))
		      (match_operand 0 "immediate_operand" "")
		      (pc)))]
  ""
  "
{
  m480_gen_compare_and_branch (LE, m480_compare_op0, m480_compare_op1, 0, operands[0]);
  DONE;
}")

(define_expand "bleu"
  [(set (pc)
	(if_then_else (leu (match_dup 1)
			   (const_int 0))
		      (match_operand 0 "immediate_operand" "")
		      (pc)))]
  ""
  "
{
  m480_gen_compare_and_branch (LEU, m480_compare_op0, m480_compare_op1, 0, operands[0]);
  DONE;
}")

(define_insn "tablejump"
  [(set (pc) (match_operand:SI 0 "register_operand" "rZ"))
   (use (match_operand 1 "immediate_operand" ""))]
  ""
  "br	%r0	; tablejump %*"
  [(set_attr "type" "branch")
   (set_attr "instruction" "br")
   (set_attr "octave_class" "branchop")])

